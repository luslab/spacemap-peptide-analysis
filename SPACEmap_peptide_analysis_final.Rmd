---
title: "Analysis of the crosslinked and released fractions of peptides from SPACEmap"
author: "Sviatoslav Sidorov"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
   html_document:
     code_folding: hide
     collapsed: no
     fig_align: center
     fig_caption: yes
     highlight: haddock
     keep_md: yes
     number_sections: yes
     smooth_scroll: no
     toc: yes
     toc_depth: 3
     toc_float: yes
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/rstudio") # Please change to yours
knitr::opts_chunk$set(echo = TRUE)
stringsAsFactors = F

library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(tibble)
library(ggplot2)
library(ggrepel)
dyn.load("/home/rstudio/libs/libicudata.so.67")
dyn.load("/home/rstudio/libs/libicuuc.so.67")
dyn.load("/home/rstudio/libs/libxml2.so.2")
dyn.load("/home/rstudio/libs/libiconv.so.2")
library(kableExtra)
library(scales)
library(tictoc)
library(seqinr)
```

## Obtain the table of InterPro matches in peptides from crosslinked fraction

Using InterProScan, we scanned all proteins containing at least one peptide from the crosslinked fraction (see `scan_clf.sh`).

Upload and filter the scan results; calculate integrated coordinates of the matches:

```{r, include=T}
signature.overlap.fraction = 0.7

find_consensus_matches = function(start, stop) {
  df = data.frame(int.start.cons = start,
                  int.stop.cons = stop,
                  stringsAsFactors = F)
  
  i = 1
  while (i <= nrow(df)) {
    start.i = df[i, ]$int.start.cons
    stop.i = df[i, ]$int.stop.cons
    j = i + 1
    while (j <= nrow(df)) {
      start.j = df[j, ]$int.start.cons
      stop.j = df[j, ]$int.stop.cons
      i.length = stop.i - start.i + 1
      j.length = stop.j - start.j + 1
      i.j.overlap.size = min(stop.i, stop.j) - max(start.i, start.j) + 1
      if ((i.j.overlap.size > signature.overlap.fraction * i.length) | 
          (i.j.overlap.size > signature.overlap.fraction * j.length)) {
        new.start.cons = min(start.i, start.j)
        new.stop.cons = max(stop.i, stop.j)
        old.start.cons.i = df[i, ]$int.start.cons
        old.stop.cons.i = df[i, ]$int.stop.cons
        df[i, ]$int.start.cons = new.start.cons
        df[i, ]$int.stop.cons = new.stop.cons
        start.i = new.start.cons
        stop.i = new.stop.cons
        df[j, ]$int.start.cons = new.start.cons
        df[j, ]$int.stop.cons = new.stop.cons
      }
      j = j + 1
    }
    i = i + 1
  }
  
  return(df %>% 
           dplyr::select(int.start.cons,
                         int.stop.cons))
    
}

# Read the InterProScan results
clf.ipr.matches = read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r clf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r clf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Define functions to plot InterPro scan results for a protein by UniProt ID:

```{r, include=T}
generate_protein_df = function(UniProtId) {
  return(read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                    header = F,
                    colClasses = c("character",
                                   "character",
                                   "numeric",
                                   "character",
                                   "character",
                                   "character",
                                   "numeric",
                                   "numeric",
                                   "character",
                                   "character",
                                   "character",
                                   "character",
                                   "character"),
                    col.names = c("seq.id",
                                  "md5",
                                  "seq.length",
                                  "db",
                                  "signature.accession",
                                  "signature.description",
                                  "start",
                                  "stop",
                                  "score",
                                  "status",
                                  "date",
                                  "ipr.accession",
                                  "ipr.description")) %>%
         filter(status == "T") %>%
         # Select domains that are integrated into InterPro (ipr.accession != "") and 
         # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
         # Parse the protein sequence headers and take the Uniprot IDs
         group_by(seq.id) %>%
         mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
         ungroup() %>%
         filter(uniprot.id == UniProtId))
}

preprocess_protein_df = function(protein.df) {
  c = 10 # vertical space between InterPro entries
  h = 5  # height of a match rectangle
  d = 5  # vertical space between rectangles
  
  protein.df = protein.df %>%
    dplyr::select(seq.length,
                  signature.accession,
                  uniprot.id,
                  start,
                  stop,
                  ipr.accession) %>%
    dplyr::rename(length = seq.length,
                           db.accession = signature.accession) %>%
    arrange(desc(start), desc(stop))
  
  ipr.numbers = unique(protein.df$ipr.accession)
  ipr.numbers = ipr.numbers[ipr.numbers != ""]
  ipr.numbers = c(ipr.numbers, "")
  names(ipr.numbers) = as.character(1:(length(ipr.numbers)))
  
  protein.df = protein.df %>%
    rowwise() %>%
    mutate(ipr.n = as.numeric(names(ipr.numbers[ipr.numbers == ipr.accession]))) %>%
    arrange(ipr.n) %>%
    rownames_to_column(var = "row.n") %>%
    mutate(row.n = as.numeric(row.n)) %>%
    mutate(ymin = ipr.n * c + (row.n - 1) * (h + d)) %>%
    mutate(ymax = ymin + h)
  
  return(protein.df)
}

generate_ipr_df = function(protein.df) {
  ipr.label.shift.x = -10
  ipr.label.shift.y = 5
  return(protein.df %>%
         dplyr::select(ipr.accession,
                       start,
                       stop,
                       ymax) %>%
         group_by(ipr.accession) %>%
         do(mutate(., ipr.x = (min(.$start) + max(.$stop)) / 2 + ipr.label.shift.x)) %>%
         do(mutate(., ipr.y = max(.$ymax) + ipr.label.shift.y)) %>%
         ungroup() %>%
         dplyr::select(ipr.accession,
                       ipr.x,
                       ipr.y) %>%
         distinct())
}

draw_matches = function(uniprot.id) {
  signature.label.shift.x = 30
  label.font.size = 3
  x.axis.extension = 50
  
  protein.df = generate_protein_df(uniprot.id)
  
  protein.df = preprocess_protein_df(protein.df)
  
  ipr.df = generate_ipr_df(protein.df)
  
  ggplot(protein.df) +
    # Matches
    geom_rect(mapping = aes(xmin = start,
                            xmax = stop,
                            ymin = ymin,
                            ymax = ymax,
                            fill = db.accession)) +
    # Signature IDs
    geom_text(aes(x = stop + signature.label.shift.x,
                  y = (ymin + ymax) / 2,
                  label = db.accession),
              size = label.font.size) +
    # InterPro IDs
    geom_text(data = ipr.df,
              aes(x = ipr.x,
                  y = ipr.y,
                  label = ipr.accession),
              size = label.font.size) +
    # Protein C-terminal mark
    geom_vline(xintercept = unlist(protein.df[1, "length"])) + 
    # Ruler
    scale_x_continuous(n.breaks = 7, 
                       limits = c(0, unlist(protein.df[1, "length"]) + x.axis.extension)) +
    # Formatting
    theme_classic() + 
    theme(axis.line.y = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.x = element_blank(),
          legend.position="none")
}
```

Print an example of scanning results from InterProScan:

```{r}
draw_matches("A2A4P0")
```

## Find overlaps of matches with peptides from crosslinked fraction

Join the InterPro match table with the CLF peptide and SPACE protein annotation tables (take the intersection with the annotation table, as the annotation table is the reference, i. e. peptides from SPACE):

```{r, include=T}
# Read in the table of proteins and peptides from SPACEmap CLF
peptide.table = read.delim("input/Crosslinked_fraction_CLF.tsv",
                           header = T,
                           sep = "\t",
                           stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names)

# Read the table of chromatin-binding proteins (CBPs) identified by SPACE
annot.table.cbp = read.delim("input/SPACE_chromatin-binders.txt", 
                             header = T,
                             sep = "\t",
                             stringsAsFactors = F)

# Read the table of RNA-binding proteins (RBPs) identified by SPACE
annot.table.rbp = read.delim("input/SPACE_RBP_All.txt", 
                             header = T,
                             sep = "\t",
                             stringsAsFactors = F)

# Read the table of proteins and peptides identified by SPACE
annot.table = read.delim("input/SPACE.txt", 
                         header = T,
                         sep = "\t",
                         stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID) %>% 
  left_join(annot.table.cbp %>%
              dplyr::select(Uniprot.ID,
                            Gene.names),
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  dplyr::rename("is.cbp" = "Gene.names") %>%
  mutate(is.cbp = !is.na(is.cbp)) %>%
  left_join(annot.table.rbp %>%
              dplyr::select(Uniprot.ID,
                            Gene.names),
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  dplyr::rename("is.rbp" = "Gene.names") %>%
  mutate(is.rbp = !is.na(is.rbp))

clf.ipr.matches.base = annot.table %>%
  left_join(clf.ipr.matches,
            by = c("Uniprot.ID" = "uniprot.id")) %>%
  left_join(peptide.table,
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  filter(!is.na(ipr.accession))
```

Next, take only domain and disordered region matches overlapping with the CLF peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

clf.ipr.matches.overlap = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Define functions for drawing peptide matches:

```{r, include=T}
draw_peptides = function(UniProtId) {
  x.axis.extension = 50
  y.axis.extension = 100
  ymin.const = 5
  ymax.const = 10
  
  protein.df = clf.ipr.matches.overlap %>%
    filter(Uniprot.ID == UniProtId) %>%
    dplyr::select(Sequence,
                  N.term.cleavage.window,
                  C.term.cleavage.window,
                  Start.position,
                  End.position) %>%
    mutate(ymin = ymin.const,
           ymax = ymax.const)
  
  protein.length = read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
    filter(status == "T") %>%
    # Select domains that are integrated into InterPro (ipr.accession != "") and 
    # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
    filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
    # Parse the protein sequence headers and take the Uniprot IDs
    group_by(seq.id) %>%
    mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
    ungroup() %>%
    filter(uniprot.id == UniProtId) %>%
    pull(seq.length) %>%
    unique()
  
  ggplot(protein.df) +
    # Matches
    geom_rect(mapping = aes(xmin = Start.position,
                            xmax = End.position,
                            ymin = ymin,
                            ymax = ymax)) +
    # Protein C-terminal mark
    geom_vline(xintercept = protein.length) + 
    # Ruler
    scale_x_continuous(n.breaks = 7, 
                       limits = c(0, protein.length + x.axis.extension)) +
    # y scale
    scale_y_continuous(limits = c(0, ymax.const + y.axis.extension)) + 
    # Formatting
    theme_classic() + 
    theme(axis.line.y = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.x = element_blank(),
          legend.position="none")
}
```

Draw matches for the example protein (A2A4P0):

```{r, include=T}
draw_peptides("A2A4P0")
```

Now we have `r clf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r clf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` CLF peptides (or residing no farther than 10 amino acids from them) from `r clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Generate SPACEmap-CLF vs SPACE stats

Calculate the proportion of shared matched peptides for Fig. 4B:

```{r, include=T}
space.proteins = annot.table %>%
  pull(Uniprot.ID) %>%
  unique()

spacemap.proteins = peptide.table %>%
  pull(Uniprot.ID) %>%
  unique()

sp.sp2.intersection.proteins = intersect(space.proteins, spacemap.proteins)

sp.sp2.intersection.peptides = peptide.table %>%
  # Take only shared proteins
  filter(Uniprot.ID %in% sp.sp2.intersection.proteins) %>%
  # Take all peptides from the shared proteins - these are shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

sp.sp2.intersection.peptides.matched = sp.sp2.intersection.peptides %>%
  # Determine which shared peptides are matched
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID",
                   "Sequence", 
                   "N.term.cleavage.window",
                   "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  # Take all matched shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()
```

Additionally, also for Fig. 4B, stratify all matched shared CLF peptides into those matched to domains and to IDRs:

```{r, include=T}
sp.sp2.intersection.peptides.matched.bytype = sp.sp2.intersection.peptides %>%
  # Determine which shared peptides are matched
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID",
                   "Sequence", 
                   "N.term.cleavage.window",
                   "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  # Take all matched shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window,
                ipr.accession) %>%
  distinct() %>%
  mutate(region.type = ifelse(ipr.accession == "", "IDR", "Domain")) %>%
  dplyr::select(-ipr.accession) %>%
  distinct() %>%
  group_by(Uniprot.ID,
           Sequence, 
           N.term.cleavage.window,
           C.term.cleavage.window) %>%
  mutate(region.type.final = ifelse(("Domain" %in% region.type) & 
                                    ("IDR" %in% region.type), 
                                    "Both", 
                                    region.type)) %>%
  ungroup() %>%
  dplyr::select(-region.type) %>%
  distinct()

domain.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  filter(region.type.final == "Domain") %>%
  nrow()

idr.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  filter(region.type.final == "IDR") %>%
  nrow()

both.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  filter(region.type.final == "Both") %>%
  nrow()

all.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  nrow()

data.frame(feature = c(rep("Peptides", 3)),
           region.type = c("Domain", "IDR", "Both"),
           fraction = c(domain.matches.n / all.matches.n,
                        idr.matches.n / all.matches.n,
                        both.matches.n / all.matches.n)) %>%
  mutate(region.type = factor(region.type, levels = rev(region.type))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = region.type)) +
    theme_classic()
```

There are `r length(space.proteins)` SPACE proteins and `r length(spacemap.proteins)` SPACEmap proteins from the crosslinked fraction. SPACE and SPACEmap-CLF have `r length(sp.sp2.intersection.proteins)` proteins in common. `r nrow(sp.sp2.intersection.peptides)` CLF peptides come from the shared proteins, and `r nrow(sp.sp2.intersection.peptides.matched)` of these peptides match at least one domain or IDR. Hence, the proportion of matched CLF peptides among all CLF peptides from the shared proteins is `r nrow(sp.sp2.intersection.peptides.matched) / nrow(sp.sp2.intersection.peptides)`.

Write down the tables of shared CLF peptides (all and matched):

```{r, include=T}
# Create the output directory, if it does not exist
dir.create("output")

# Load the table of peptides from SPACEmap for annotation purposes
peptide.table.whole = read.delim("input/Crosslinked_fraction_CLF.tsv",
                                 header = T,
                                 sep = "\t",
                                 stringsAsFactors = F)

# All shared peptides
write.table(sp.sp2.intersection.peptides %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_all.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Matched shared peptides
write.table(sp.sp2.intersection.peptides.matched %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_matched.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Matched shared peptides with the match info
write.table(clf.ipr.matches.overlap %>%
              dplyr::select(Gene.names,
                            Protein.names,
                            Uniprot.ID,
                            Sequence,
                            N.term.cleavage.window,
                            C.term.cleavage.window,
                            Start.position,
                            End.position,
                            int.start,
                            int.stop,
                            ipr.accession,
                            ipr.description) %>%
              dplyr::rename("Peptide.start" = "Start.position",
                            "Peptide.stop" = "End.position",
                            "Match.start" = "int.start",
                            "Match.stop" = "int.stop",
                            "InterPro.accession" = "ipr.accession",
                            "InterPro.description" = "ipr.description") %>%
              arrange(Gene.names,
                      Protein.names,
                      N.term.cleavage.window,
                      C.term.cleavage.window,
                      Peptide.start,
                      Peptide.stop,
                      Match.start,
                      Match.stop) %>%
              mutate(InterPro.description = ifelse(InterPro.description == "",
                                                   "Disordered region",
                                                   InterPro.description)),
            "output/space_spacemap-clf_shared_peptides_matched_with-matches.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Select only chromatin- and RNA-binding CLF proteins

From the whole table of shared CLF proteins, select only chromatin-binding proteins (CBPs) and RNA-binding proteins (RBPs) for further analysis:

```{r, include=T}
clf.ipr.matches.overlap.cbp_rbp = clf.ipr.matches.overlap %>%
  filter(is.cbp | is.rbp)

write.table(clf.ipr.matches.overlap.cbp_rbp,
            "output/clf_matches_in_cbp_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

We have `r clf.ipr.matches.overlap.cbp_rbp %>% filter(is.cbp) %>% pull(Uniprot.ID) %>% unique() %>% length()` shared CBPs and `r clf.ipr.matches.overlap.cbp_rbp %>% filter(is.rbp) %>% pull(Uniprot.ID) %>% unique() %>% length()` shared RBPs (some of these proteins are CBPs and RBPs at the same time). In total, we lost `r (clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()) - (clf.ipr.matches.overlap.cbp_rbp %>%  pull(Uniprot.ID) %>% unique() %>% length())` as they are neither marked as CBPs nor as RBPs.

## Process matches in peptides from released fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the SPACEmap released fraction, also captured by SPACE (see `scan_rf.sh`).

Read and process the results of scanning of proteins enriched in the released fraction of SPACEmap and also in SPACE:

```{r, include=T}
# Read in the InterProScan results
rf.ipr.matches = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r rf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r rf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Join the InterPro match table for the released fraction with the peptide table for the same fraction:

```{r, include=T}
peptide.table.rf = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.tsv",
                              header = T,
                              sep = "\t",
                              stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names)

rf.ipr.matches.base = rf.ipr.matches %>%
  dplyr::rename(Uniprot.ID = uniprot.id) %>%
  left_join(peptide.table.rf,
            by = c("Uniprot.ID" = "Uniprot.ID"))
```

Next, take only domain and disordered region matches that overlap with a shared released peptide or reside no farther than 10 amino acids from the ends of a peptide:

```{r, include=T}
match.vicinity = 10 # amino acids

rf.ipr.matches.overlap = rf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r rf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r rf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` shared released peptides (or residing no father than 10 amino acids from them) from `r rf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

Write down the table of released peptides (shared between SPACE and SPACEmap) and their matches:

```{r, include=T}
write.table(rf.ipr.matches.overlap %>%
              dplyr::select(Gene.names,
                            Protein.names,
                            Uniprot.ID,
                            Sequence,
                            N.term.cleavage.window,
                            C.term.cleavage.window,
                            Start.position,
                            End.position,
                            int.start,
                            int.stop,
                            ipr.accession,
                            ipr.description) %>% 
              dplyr::rename("Peptide.start" = "Start.position",
                            "Peptide.stop" = "End.position",
                            "Match.start" = "int.start",
                            "Match.stop" = "int.stop",
                            "InterPro.accession" = "ipr.accession",
                            "InterPro.description" = "ipr.description") %>%
              arrange(Gene.names,
                      Protein.names,
                      N.term.cleavage.window,
                      C.term.cleavage.window,
                      Peptide.start,
                      Peptide.stop,
                      Match.start,
                      Match.stop) %>%
              mutate(InterPro.description = ifelse(InterPro.description == "",
                                                   "Disordered region",
                                                   InterPro.description)),
            "output/space_spacemap-rf_shared_peptides_matched_with-matches.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Amino-acid frequencies in matched peptides

Calculate frequencies of amino acids from peptides matched in the crosslinked and released fractions. Do separate calculations for peptides matched to domains and to disordered regions (these two sets of peptides may overlap, as one and the same peptide could match both to a domain and to a disordered region). Also, calculate frequencies of amino acids in matches in all peptides (the full proteome).

```{r, include=T}
aa.names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")

count_aas = function(aa.str) {
  aa.str.vec = strsplit(aa.str, "")[[1]]
  aa.counts = unlist(purrr::map(aa.names, 
                                function(x) {
                                  return(length(aa.str.vec[aa.str.vec == x]))
                                }))
  return(aa.counts)
}

# Frequencies of amino acids in domain-matching peptides from CLF
clf.ipr.matches.overlap.sequences.dom = clf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.clf.sum = sum(unique.aa.dict.dom.clf)
unique.aa.dict.dom.clf.freq = unlist(purrr::map(unique.aa.dict.dom.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.clf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from CLF
clf.ipr.matches.overlap.sequences.idr = clf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.clf.sum = sum(unique.aa.dict.idr.clf)
unique.aa.dict.idr.clf.freq = unlist(purrr::map(unique.aa.dict.idr.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.clf.sum
                                                }))

# Frequencies of amino acids in domain-matching peptides from RF
rf.ipr.matches.overlap.sequences.dom = rf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.rf.sum = sum(unique.aa.dict.dom.rf)
unique.aa.dict.dom.rf.freq = unlist(purrr::map(unique.aa.dict.dom.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.rf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from RF
rf.ipr.matches.overlap.sequences.idr = rf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.rf.sum = sum(unique.aa.dict.idr.rf)
unique.aa.dict.idr.rf.freq = unlist(purrr::map(unique.aa.dict.idr.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.rf.sum
                                                }))

# Table of the peptides from the full proteome
clf.peptides = annot.table %>%
  left_join(peptide.table, by = "Uniprot.ID") %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  filter(!is.na(Sequence)) %>%
  distinct()
rf.peptides = peptide.table.rf %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()
fp.peptides = clf.peptides %>%
  bind_rows(rf.peptides)

# Frequencies of amino acids in peptides from the full proteome (CLF + RF)
fp.sequences = fp.peptides %>%
  pull(Sequence)

unique.aa.dict.fp = count_aas(purrr::reduce(fp.sequences, paste0))
unique.aa.dict.fp.sum = sum(unique.aa.dict.fp)
unique.aa.dict.fp.freq = unlist(purrr::map(unique.aa.dict.fp, 
                                                function(x) {
                                                  x / unique.aa.dict.fp.sum
                                                }))
```

Plot the frequencies of amino acids from domain-matching peptides in CLF vs RF (Fig. 4F, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           rf = unique.aa.dict.dom.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids from disordered region-matching peptides in CLF vs RF (Fig. 4G, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           rf = unique.aa.dict.idr.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in domain-matching peptides from CLF vs full proteome (Fig. 4F, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in disordered region-matching peptides in CLF vs full proteome (Fig. 4G, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

## Find the most frequent InterPro entries

Plot the frequencies of the top matched InterPro entries:

```{r, include=T, fig.height=8}
uniprotid.db.total.num = clf.ipr.matches.overlap.cbp_rbp %>% 
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.freq = clf.ipr.matches.overlap.cbp_rbp %>%
  group_by(ipr.accession) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

clf.ipr.matches.overlap.cbp_rbp.freq %>%
  filter(uniprotid.freq >= 0.01) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "red") +
    scale_y_continuous(limits = c(0, 0.5), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the overall table of InterPro entry frequencies:

```{r, include=T}
write.table(clf.ipr.matches.overlap.cbp_rbp.freq,
            "output/clf_matches_in_db_and_rbp_freq.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Generalise (cluster) all matched InterPro entries

Do an automatical clusterisation of similar InterPro entries matched in CLF peptides (from CBPs and RBPs) shared between SPACEmap and SPACE: If two InterPro entries co-match at least once and in >=70% of co-matches they overlap by >=70% of their lengths, reciprocally, then we put them in one cluster (generalised entry). To maintain clusters, we use disjoint set union:

```{r, include=T}
tic("Clusterisation of matched InterPro entries")

good_overlap_fraction_cutoff = 0.7

overlap_size_cutoff = 0.7

ipr_overlap_list = list()

iprs = c()

i_overlaps_j = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  return(min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1 > 0)
}

i_overlaps_j_well = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  overlap_size = min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1
  ipr_i_length = ipr_i_stop - ipr_i_start + 1
  ipr_j_length = ipr_j_stop - ipr_j_start + 1
  return((overlap_size >= overlap_size_cutoff * ipr_i_length) & 
         (overlap_size >= overlap_size_cutoff * ipr_j_length))
}

count_overlaps = function(gene_df) {
  gene_df = gene_df %>%
    dplyr::select(Uniprot.ID,
                  ipr.accession,
                  ipr.description,
                  int.start,
                  int.stop) %>%
    distinct()
  
  i = 0
  while (i < nrow(gene_df)) {
    i = i + 1
    ipr_i = as.character(gene_df[i, "ipr.accession"])
    ipr_i = ifelse(ipr_i == "", "disordered_region", ipr_i)
    iprs <<- c(iprs, ipr_i)
    j = i
    while (j < nrow(gene_df)) {
      j = j + 1
      ipr_j = as.character(gene_df[j, "ipr.accession"])
      ipr_j = ifelse(ipr_j == "", "disordered_region", ipr_j)
      iprs <<- c(iprs, ipr_j)
      if ((ipr_i != ipr_j) & (ipr_i != "disordered_region") & (ipr_j != "disordered_region")) {
        ipr_pair_name = paste0(ipr_i, "_", ipr_j)
        ipr_i_start = gene_df[i, "int.start"]
        ipr_i_stop = gene_df[i, "int.stop"]
        ipr_j_start = gene_df[j, "int.start"]
        ipr_j_stop = gene_df[j, "int.stop"]
        if (i_overlaps_j(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
          if (is.null(ipr_overlap_list[[ipr_pair_name]])) {
            ipr_overlap_list[[ipr_pair_name]] <<- list()
            ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- 0
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- 0
          }
          ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$all_overlaps + 1
          if (i_overlaps_j_well(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$good_overlaps + 1
          }
        }
      }
    }
  }
  iprs <<- unique(iprs)
}

# Form a list of overlapping IPR pairs
uniprot.ids = clf.ipr.matches.overlap.cbp_rbp %>%
  pull(Uniprot.ID) %>%
  unique()

for (uniprot.id in uniprot.ids) {
  count_overlaps(clf.ipr.matches.overlap.cbp_rbp %>% filter(Uniprot.ID == uniprot.id))
}

# Cluster InterPro entries by overlaps

# List to store disjoint sets
parent = list()

# List to store set ranks
set.size = list()

# DSU (Disjoint Set Union) functions
make_set = function(v) {
	parent[v] <<- v
	set.size[v] <<- 1
}

find_set = function(v) {
	if (v == unlist(parent[v])) {
	  return(v)
	}
	return(parent[v] <<- find_set(unlist(parent[v])))
}

merge_sets = function(a, b) {
	a = find_set(a)
	b = find_set(b)
	if (a != b) {
	  if (unlist(set.size[a]) > unlist(set.size[b])) {
	    parent[b] <<- a
	    set.size[a] <<- unlist(set.size[a]) + unlist(set.size[b])
	  } else {
	    parent[a] <<- b
	    set.size[b] <<- unlist(set.size[b]) + unlist(set.size[a])
	  }
	}
}

for (ipr in iprs) {
  make_set(ipr)
}

for (ipr_pair_name in names(ipr_overlap_list)) {
  if (ipr_overlap_list[[ipr_pair_name]]$good_overlaps / 
      ipr_overlap_list[[ipr_pair_name]]$all_overlaps >= 
      good_overlap_fraction_cutoff) {
    ipr_i = unlist(stringr::str_split(ipr_pair_name, "_"))[1]
    ipr_j = unlist(stringr::str_split(ipr_pair_name, "_"))[2]
    merge_sets(ipr_i, ipr_j)
  }
}

# Form the table of the found clusters
lead.ipr.table = data.frame(lead.ipr = unlist(parent),
                            ipr.accession = names(parent),
                            stringsAsFactors = F) %>%
  arrange(lead.ipr) %>%
  left_join(clf.ipr.matches.overlap.cbp_rbp %>%
              dplyr::select(ipr.accession,
                            ipr.description) %>%
              distinct(),
            by = c("ipr.accession"))

row.names(lead.ipr.table) = NULL

unique.lead.iprs = lead.ipr.table %>%
  pull(lead.ipr) %>%
  unique()

ipr.cluster.table = lead.ipr.table %>%
  left_join(data.frame(lead.ipr = unique.lead.iprs,
                       cluster.name = seq(1:length(unique.lead.iprs)),
                       stringsAsFactors = F),
            by = c("lead.ipr")) %>%
  dplyr::select(cluster.name,
                ipr.accession,
                ipr.description) %>%
  group_by(cluster.name) %>%
  mutate(cluster.size = length(ipr.accession)) %>%
  ungroup() %>%
  arrange(desc(cluster.size))

# Write down the table of all clusters
write.table(ipr.cluster.table,
            "output/match_clusters_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

toc()
# ~ 5 sec
```

Name clusters that are present in the plots below, according to the InterPro entries that these clusters contain:

```{r, include=T}
ipr.cluster.table = ipr.cluster.table %>%
  mutate(cluster.name = ifelse(cluster.name == "1", "Disordered region", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "526", "P-loop-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "755", "HTH", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "347", "RRM", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "91", "C2H2-type ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "276", "OB-fold", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "49", "Helicase, C-terminal", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "602", "Armadillo-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "729", "DEAD-box-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "50", "WD40 repeat", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "560", "SAM methyltransferase-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "391", "WD40-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "535", "WD40/YVTN-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "578", "MCM protein", cluster.name))
```

## Find frequencies of cluster matches

First, apply our clusterisation to the main table with matched CLF peptides from CBPs and RBPs:

```{r, include=T}
clf.ipr.matches.overlap.cbp_rbp.collated = clf.ipr.matches.overlap.cbp_rbp %>%
  mutate(ipr.accession = ifelse(ipr.accession == "", "disordered_region", ipr.accession)) %>%
  mutate(ipr.description = ifelse(ipr.description == "", "disordered_region", ipr.description)) %>%
  left_join(ipr.cluster.table %>%
              mutate(ipr.description = ifelse(is.na(ipr.description), "disordered_region", ipr.description)),
            by = c("ipr.accession", "ipr.description")) %>%
  filter(!is.na(cluster.name)) %>%
  mutate(ipr.accession = "") %>%
  mutate(ipr.description = cluster.name)
```

Secondly, generate tables with the frequencies of proteins and peptides with different matches (plot top 10 matches by frequency).

For the CBPs (Fig. 4E; Fig. S4E, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.cbp = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.cbp) %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.cbp) %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.cbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq,
            "output/clf_cbp_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 60), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the RBPs (Fig. 4D; Fig. S4D, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.rbp) %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.rbp) %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.rbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq,
            "output/clf_rbp_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 50), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from CBPs (Fig. S4E, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.cbp) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.cbp) %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.db.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides,
            "output/clf_db_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 40), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from RBPs (Fig. S4D, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.rbp) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.rbp) %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.rbp.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides,
            "output/clf_rbp_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 30), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the table of generalised entries:

```{r, include=T}
write.table(ipr.cluster.table,
            "output/cluster_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```
