---
title: "Analysis of the crosslinked and released fractions of peptides from SPACEmap"
author: "Sviatoslav Sidorov"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
   html_document:
     code_folding: hide
     collapsed: no
     fig_align: center
     fig_caption: yes
     highlight: haddock
     keep_md: yes
     number_sections: yes
     smooth_scroll: no
     toc: yes
     toc_depth: 3
     toc_float: yes
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/rstudio") # Please change to yours
knitr::opts_chunk$set(echo = TRUE)
stringsAsFactors = F

library(dplyr)
library(stringr)
library(purrr)
library(tibble)
library(ggplot2)
library(ggrepel)
library(kableExtra)
library(scales)
library(tictoc)
library(seqinr)
```

## Obtain the table of InterPro matches in peptides from crosslinked fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the crosslinked fraction (see `scan_clf.sh`).

Upload and filter the scan results; calculate integrated coordinates of the matches:

```{r, include=T}
signature.overlap.fraction = 0.7

find_consensus_matches = function(start, stop) {
  df = data.frame(int.start.cons = start,
                  int.stop.cons = stop,
                  stringsAsFactors = F)
  
  i = 1
  while (i <= nrow(df)) {
    start.i = df[i, ]$int.start.cons
    stop.i = df[i, ]$int.stop.cons
    j = i + 1
    while (j <= nrow(df)) {
      start.j = df[j, ]$int.start.cons
      stop.j = df[j, ]$int.stop.cons
      i.length = stop.i - start.i + 1
      j.length = stop.j - start.j + 1
      i.j.overlap.size = min(stop.i, stop.j) - max(start.i, start.j) + 1
      if ((i.j.overlap.size > signature.overlap.fraction * i.length) | 
          (i.j.overlap.size > signature.overlap.fraction * j.length)) {
        new.start.cons = min(start.i, start.j)
        new.stop.cons = max(stop.i, stop.j)
        old.start.cons.i = df[i, ]$int.start.cons
        old.stop.cons.i = df[i, ]$int.stop.cons
        df[i, ]$int.start.cons = new.start.cons
        df[i, ]$int.stop.cons = new.stop.cons
        start.i = new.start.cons
        stop.i = new.stop.cons
        df[j, ]$int.start.cons = new.start.cons
        df[j, ]$int.stop.cons = new.stop.cons
      }
      j = j + 1
    }
    i = i + 1
  }
  
  return(df %>% 
           dplyr::select(int.start.cons,
                         int.stop.cons))
    
}

# Read the InterProScan results
clf.ipr.matches = read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r clf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r clf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

## Find overlaps of matches with peptides

Join the InterPro match table with the peptide and protein annotation tables (take the intersection with the annotation table, as the annotation table is the reference - peptides from SPACE):

```{r, include=T}
# Read in the table of proteins and peptides from SPACEmap CLF
peptide.table = read.delim("input/Crosslinked_fraction_CLF.tsv",
                           header = T,
                           sep = "\t",
                           stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                Gene.names,
                Protein.names)

# Read the table of proteins and peptides identified by SPACE
annot.table = read.delim("input/mES_enriched_SPACE.tsv",
                         header = T,
                         sep = "\t",
                         stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Category,
                RBP)

clf.ipr.matches.base = annot.table %>%
  left_join(clf.ipr.matches,
            by = c("Uniprot.ID" = "uniprot.id")) %>%
  left_join(peptide.table,
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  filter(!is.na(ipr.accession))
```

Now we have `r clf.ipr.matches.base %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.base %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered region matches in `r clf.ipr.matches.base %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins. The total number of peptides is `r clf.ipr.matches.base %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()`.

Originally, in the annotation table from SPACE, there were `r annot.table %>% filter(Category == "DB") %>% pull(Uniprot.ID) %>% unique() %>% length()` DNA-binding and `r annot.table %>% filter(RBP == "RBP") %>% pull(Uniprot.ID) %>% unique() %>% length()` RNA-binding proteins.

Next, take only domain and disordered region matches overlapping with the peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

clf.ipr.matches.overlap = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r clf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r clf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no father than 10 amino acids from them) from `r clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Generate SPACEmap vs SPACE stats

Calculate the proportion of shared matched peptides:

```{r, include=T}
space.proteins = annot.table %>%
  pull(Uniprot.ID) %>%
  unique()

spacemap.proteins = peptide.table %>%
  pull(Uniprot.ID) %>%
  unique()

sp.sp2.intersection.proteins = intersect(space.proteins, spacemap.proteins)

sp.sp2.intersection.peptides = peptide.table %>%
  # Take only shared proteins
  filter(Uniprot.ID %in% sp.sp2.intersection.proteins) %>%
  # Take all peptides from the shared proteins - these are shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

sp.sp2.intersection.peptides.matched = sp.sp2.intersection.peptides %>%
  # Determine which shared peptides are matched
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID",
                   "Sequence", 
                   "N.term.cleavage.window",
                   "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  # Take all matched shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()
```

Hence, the proportion of matched peptides in all shared peptides is `r nrow(sp.sp2.intersection.peptides.matched) / nrow(sp.sp2.intersection.peptides)`.

Write down the tables of shared peptides (all and matched):

```{r, include=T}
# Create the output directory, if it does not exist
dir.create("output")

# Load the table of peptides from SPACEmap for annotation purposes
peptide.table.whole = read.delim("input/Crosslinked_fraction_CLF.tsv",
                                 header = T,
                                 sep = "\t",
                                 stringsAsFactors = F)

# All shared peptides
write.table(sp.sp2.intersection.peptides %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_all.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Matched shared peptides
write.table(sp.sp2.intersection.peptides.matched %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_matched.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Select only DNA- and RNA-binding proteins

From the whole table, select only DNA- and RNA-binding proteins for further analysis:

```{r, include=T}
clf.ipr.matches.overlap.db_rbp = clf.ipr.matches.overlap %>%
  filter((Category == "DB") |
         (RBP == "RBP"))

write.table(clf.ipr.matches.overlap.db_rbp,
            "output/clf_matches_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

We have `r clf.ipr.matches.overlap.db_rbp %>% filter(Category == "DB") %>% pull(Uniprot.ID) %>% unique() %>% length()` DNA-binding proteins and `r clf.ipr.matches.overlap.db_rbp %>% filter(RBP == "RBP") %>% pull(Uniprot.ID) %>% unique() %>% length()` RNA-binding proteins (some of these proteins are DNA- and RNA-binding at the same time). In total, we lost `r (clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()) - (clf.ipr.matches.overlap.db_rbp %>%  pull(Uniprot.ID) %>% unique() %>% length())` as they are neither marked as DNA-binding nor as RNA-binding.

## Process matches in peptides from released fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the SPACEmap released fraction, also captured by SPACE (see `scan_rf.sh`).

Read and process the results of scanning of proteins enriched in the released fraction of SPACEmap and also in SPACE:

```{r, include=T}
# Read in the InterProScan results
rf.ipr.matches = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r rf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r rf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Next, retain only the peptides from the matched proteins that come from the released fraction and were identified by SPACE:

```{r, include=T}
peptide.table.rf = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.tsv",
                              header = T,
                              sep = "\t",
                              stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                Gene.names,
                Protein.names)

rf.ipr.matches.base = rf.ipr.matches %>%
  dplyr::rename(Uniprot.ID = uniprot.id) %>%
  left_join(peptide.table.rf,
            by = c("Uniprot.ID" = "Uniprot.ID"))
```

Now we have `r rf.ipr.matches.base %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.base %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered region matches in `r rf.ipr.matches.base %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins. The total number of peptides is `r rf.ipr.matches.base %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()`.

Next, take only domain and disordered region matches overlapping with the peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

rf.ipr.matches.overlap = rf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r rf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r rf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no father than 10 amino acids from them) from `r rf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Amino-acid frequencies in matched peptides

Calculate frequencies of amino acids from peptides matched in the crosslinked and released fractions. Do separate calculations for peptides matched to domains and to disordered regions (these two sets of peptides are overlapping, as one and the same peptide could match both to a domain and to a disordered region). Also, calculate frequencies of amino acids in matches in all peptides (the full proteome).

```{r, include=T}
aa.names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")

count_aas = function(aa.str) {
  aa.str.vec = strsplit(aa.str, "")[[1]]
  aa.counts = unlist(purrr::map(aa.names, 
                                function(x) {
                                  return(length(aa.str.vec[aa.str.vec == x]))
                                }))
  return(aa.counts)
}

# Frequencies of amino acids in domain-matching peptides from CLF
clf.ipr.matches.overlap.sequences.dom = clf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.clf.sum = sum(unique.aa.dict.dom.clf)
unique.aa.dict.dom.clf.freq = unlist(purrr::map(unique.aa.dict.dom.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.clf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from CLF
clf.ipr.matches.overlap.sequences.idr = clf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.clf.sum = sum(unique.aa.dict.idr.clf)
unique.aa.dict.idr.clf.freq = unlist(purrr::map(unique.aa.dict.idr.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.clf.sum
                                                }))

# Frequencies of amino acids in domain-matching peptides from RF
rf.ipr.matches.overlap.sequences.dom = rf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.rf.sum = sum(unique.aa.dict.dom.rf)
unique.aa.dict.dom.rf.freq = unlist(purrr::map(unique.aa.dict.dom.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.rf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from RF
rf.ipr.matches.overlap.sequences.idr = rf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.rf.sum = sum(unique.aa.dict.idr.rf)
unique.aa.dict.idr.rf.freq = unlist(purrr::map(unique.aa.dict.idr.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.rf.sum
                                                }))

# Table of the peptides from the full proteome
clf.peptides = annot.table %>%
  left_join(peptide.table, by = "Uniprot.ID") %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  filter(!is.na(Sequence)) %>%
  distinct()
rf.peptides = peptide.table.rf %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()
fp.peptides = clf.peptides %>%
  bind_rows(rf.peptides)

# Frequencies of amino acids in peptides from the full proteome (CLF + RF)
fp.sequences = fp.peptides %>%
  pull(Sequence)

unique.aa.dict.fp = count_aas(purrr::reduce(fp.sequences, paste0))
unique.aa.dict.fp.sum = sum(unique.aa.dict.fp)
unique.aa.dict.fp.freq = unlist(purrr::map(unique.aa.dict.fp, 
                                                function(x) {
                                                  x / unique.aa.dict.fp.sum
                                                }))
```

Plot the frequencies of amino acids from domain-matching peptides in CLF vs RF (Fig. 3E, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           rf = unique.aa.dict.dom.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids from disordered region-matching peptides in CLF vs RF (Fig. 3E, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           rf = unique.aa.dict.idr.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in domain-matching peptides from CLF vs full proteome (Fig. S3F, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in disordered region-matching peptides in CLF vs full proteome (Fig. S3F, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

## Find the most frequent InterPro entries

Plot the frequencies of the top matched InterPro entries:

```{r, include=T, fig.height=8}
uniprotid.db.total.num = clf.ipr.matches.overlap.db_rbp %>% 
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.freq = clf.ipr.matches.overlap.db_rbp %>%
  group_by(ipr.accession) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

clf.ipr.matches.overlap.db_rbp.freq %>%
  filter(uniprotid.freq >= 0.01) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "red") +
    scale_y_continuous(limits = c(0, 0.5), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the overall table of InterPro entry frequencies:

```{r, include=T}
write.table(clf.ipr.matches.overlap.db_rbp.freq,
            "output/clf_matches_in_db_and_rbp_freq.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Generalise (cluster) all matched InterPro entries

Do an automatical clusterisation of similar InterPro entries: If two InterPro entries co-match at least once and in >=70% of co-matches they overlap by >=70% of their lengths, reciprocally, then we put them in one cluster (generalised entry). To maintain clusters, we use disjoint set union:

```{r, include=T}
tic("Clusterisation of matched InterPro entries")

good_overlap_fraction_cutoff = 0.7

overlap_size_cutoff = 0.7

ipr_overlap_list = list()

iprs = c()

i_overlaps_j = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  return(min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1 > 0)
}

i_overlaps_j_well = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  overlap_size = min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1
  ipr_i_length = ipr_i_stop - ipr_i_start + 1
  ipr_j_length = ipr_j_stop - ipr_j_start + 1
  return((overlap_size >= overlap_size_cutoff * ipr_i_length) & 
         (overlap_size >= overlap_size_cutoff * ipr_j_length))
}

count_overlaps = function(gene_df) {
  gene_df = gene_df %>%
    dplyr::select(Uniprot.ID,
                  ipr.accession,
                  ipr.description,
                  int.start,
                  int.stop) %>%
    distinct()
  
  i = 0
  while (i < nrow(gene_df)) {
    i = i + 1
    ipr_i = as.character(gene_df[i, "ipr.accession"])
    ipr_i = ifelse(ipr_i == "", "disordered_region", ipr_i)
    iprs <<- c(iprs, ipr_i)
    j = i
    while (j < nrow(gene_df)) {
      j = j + 1
      ipr_j = as.character(gene_df[j, "ipr.accession"])
      ipr_j = ifelse(ipr_j == "", "disordered_region", ipr_j)
      iprs <<- c(iprs, ipr_j)
      if ((ipr_i != ipr_j) & (ipr_i != "disordered_region") & (ipr_j != "disordered_region")) {
        ipr_pair_name = paste0(ipr_i, "_", ipr_j)
        ipr_i_start = gene_df[i, "int.start"]
        ipr_i_stop = gene_df[i, "int.stop"]
        ipr_j_start = gene_df[j, "int.start"]
        ipr_j_stop = gene_df[j, "int.stop"]
        if (i_overlaps_j(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
          if (is.null(ipr_overlap_list[[ipr_pair_name]])) {
            ipr_overlap_list[[ipr_pair_name]] <<- list()
            ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- 0
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- 0
          }
          ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$all_overlaps + 1
          if (i_overlaps_j_well(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$good_overlaps + 1
          }
        }
      }
    }
  }
  iprs <<- unique(iprs)
}

# Form a list of overlapping IPR pairs
uniprot.ids = clf.ipr.matches.overlap.db_rbp %>%
  pull(Uniprot.ID) %>%
  unique()

for (uniprot.id in uniprot.ids) {
  count_overlaps(clf.ipr.matches.overlap.db_rbp %>% filter(Uniprot.ID == uniprot.id))
}

# Cluster InterPro entries by overlaps

# List to store disjoint sets
parent = list()

# List to store set ranks
set.size = list()

# DSU (Disjoint Set Union) functions
make_set = function(v) {
	parent[v] <<- v
	set.size[v] <<- 1
}

find_set = function(v) {
	if (v == unlist(parent[v])) {
	  return(v)
	}
	return(parent[v] <<- find_set(unlist(parent[v])))
}

merge_sets = function(a, b) {
	a = find_set(a)
	b = find_set(b)
	if (a != b) {
	  if (unlist(set.size[a]) > unlist(set.size[b])) {
	    parent[b] <<- a
	    set.size[a] <<- unlist(set.size[a]) + unlist(set.size[b])
	  } else {
	    parent[a] <<- b
	    set.size[b] <<- unlist(set.size[b]) + unlist(set.size[a])
	  }
	}
}

for (ipr in iprs) {
  make_set(ipr)
}

for (ipr_pair_name in names(ipr_overlap_list)) {
  if (ipr_overlap_list[[ipr_pair_name]]$good_overlaps / 
      ipr_overlap_list[[ipr_pair_name]]$all_overlaps >= 
      good_overlap_fraction_cutoff) {
    ipr_i = unlist(stringr::str_split(ipr_pair_name, "_"))[1]
    ipr_j = unlist(stringr::str_split(ipr_pair_name, "_"))[2]
    merge_sets(ipr_i, ipr_j)
  }
}

# Form the table of the found clusters
lead.ipr.table = data.frame(lead.ipr = unlist(parent),
                            ipr.accession = names(parent),
                            stringsAsFactors = F) %>%
  arrange(lead.ipr) %>%
  left_join(clf.ipr.matches.overlap.db_rbp %>%
              dplyr::select(ipr.accession,
                            ipr.description) %>%
              distinct(),
            by = c("ipr.accession"))

row.names(lead.ipr.table) = NULL

unique.lead.iprs = lead.ipr.table %>%
  pull(lead.ipr) %>%
  unique()

ipr.cluster.table = lead.ipr.table %>%
  left_join(data.frame(lead.ipr = unique.lead.iprs,
                       cluster.name = seq(1:length(unique.lead.iprs)),
                       stringsAsFactors = F),
            by = c("lead.ipr")) %>%
  dplyr::select(cluster.name,
                ipr.accession,
                ipr.description) %>%
  group_by(cluster.name) %>%
  mutate(cluster.size = length(ipr.accession)) %>%
  ungroup() %>%
  arrange(desc(cluster.size))

# Write down the table of all clusters
write.table(ipr.cluster.table,
            "output/match_clusters_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

toc()
```

Name clusters that are present in the plots below, according to the InterPro entries that these clusters contain:

```{r, include=T}
ipr.cluster.table = ipr.cluster.table %>%
  mutate(cluster.name = ifelse(cluster.name == "1", "Disordered region", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "481", "P-loop-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "592", "HTH", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "553", "RRM", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "293", "C2H2-type ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "265", "OB-fold", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "551", "RING/FYVE/PHD ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "51", "Helicase, C-terminal", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "342", "Armadillo-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "317", "DEAD-box-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "52", "WD40 repeat", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "510", "SAM methyltransferase-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "99", "KH domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "32", "MCM domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "580", "C2H2 ZF-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "588", "WD40-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "463", "WD40/YVTN-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "518", "MCM domain-containing", cluster.name))
```

## Find frequencies of cluster matches

First, apply our clusterisation to the main table with matches and peptides:

```{r, include=T}
clf.ipr.matches.overlap.db_rbp.collated = clf.ipr.matches.overlap.db_rbp %>%
  mutate(ipr.accession = ifelse(ipr.accession == "", "disordered_region", ipr.accession)) %>%
  mutate(ipr.description = ifelse(ipr.description == "", "disordered_region", ipr.description)) %>%
  left_join(ipr.cluster.table %>%
              mutate(ipr.description = ifelse(is.na(ipr.description), "disordered_region", ipr.description)),
            by = c("ipr.accession", "ipr.description")) %>%
  filter(!is.na(cluster.name)) %>%
  mutate(ipr.accession = "") %>%
  mutate(ipr.description = cluster.name)
```

Secondly, generate tables with the frequencies of proteins and peptides with different matches (plot top 10 by frequency).

For the DNA-binding proteins (Fig. S3E, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(Category == "DB") %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.collated.db_freq = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(Category == "DB") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.db) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.db_freq,
            "output/clf_db_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.db_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 60), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the RNA-binding proteins (Fig. 3D; Fig. S3D, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.rbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

write.table(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq,
            "output/clf_rbp_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 50), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from DNA-binding proteins (Fig. S3E, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db.peptides = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(Category == "DB") %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(Category == "DB") %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.db.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides,
            "output/clf_db_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 40), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from RNA-binding proteins (Fig. S3D, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp.peptides = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.rbp.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides,
            "output/clf_rbp_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 30), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the table of generalised entries:

```{r, include=T}
write.table(ipr.cluster.table,
            "output/cluster_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```
