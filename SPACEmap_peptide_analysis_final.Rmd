---
title: "Analysis of the crosslinked and released fractions of peptides from SPACEmap"
author: "Sviatoslav Sidorov"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
   html_document:
     code_folding: hide
     collapsed: no
     fig_align: center
     fig_caption: yes
     highlight: haddock
     keep_md: yes
     number_sections: yes
     smooth_scroll: no
     toc: yes
     toc_depth: 3
     toc_float: yes
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/rstudio") # Please change to yours
knitr::opts_chunk$set(echo = TRUE)
stringsAsFactors = F

library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(tibble)
library(ggplot2)
library(ggrepel)
dyn.load("/home/rstudio/libs/libicudata.so.67")
dyn.load("/home/rstudio/libs/libicuuc.so.67")
dyn.load("/home/rstudio/libs/libxml2.so.2")
dyn.load("/home/rstudio/libs/libiconv.so.2")
library(kableExtra)
library(scales)
library(tictoc)
library(seqinr)
```

## Obtain the table of InterPro matches in peptides from crosslinked fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the crosslinked fraction (see `scan_clf.sh`).

Upload and filter the scan results; calculate integrated coordinates of the matches:

```{r, include=T}
signature.overlap.fraction = 0.7

find_consensus_matches = function(start, stop) {
  df = data.frame(int.start.cons = start,
                  int.stop.cons = stop,
                  stringsAsFactors = F)
  
  i = 1
  while (i <= nrow(df)) {
    start.i = df[i, ]$int.start.cons
    stop.i = df[i, ]$int.stop.cons
    j = i + 1
    while (j <= nrow(df)) {
      start.j = df[j, ]$int.start.cons
      stop.j = df[j, ]$int.stop.cons
      i.length = stop.i - start.i + 1
      j.length = stop.j - start.j + 1
      i.j.overlap.size = min(stop.i, stop.j) - max(start.i, start.j) + 1
      if ((i.j.overlap.size > signature.overlap.fraction * i.length) | 
          (i.j.overlap.size > signature.overlap.fraction * j.length)) {
        new.start.cons = min(start.i, start.j)
        new.stop.cons = max(stop.i, stop.j)
        old.start.cons.i = df[i, ]$int.start.cons
        old.stop.cons.i = df[i, ]$int.stop.cons
        df[i, ]$int.start.cons = new.start.cons
        df[i, ]$int.stop.cons = new.stop.cons
        start.i = new.start.cons
        stop.i = new.stop.cons
        df[j, ]$int.start.cons = new.start.cons
        df[j, ]$int.stop.cons = new.stop.cons
      }
      j = j + 1
    }
    i = i + 1
  }
  
  return(df %>% 
           dplyr::select(int.start.cons,
                         int.stop.cons))
    
}

# Read the InterProScan results
clf.ipr.matches = read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r clf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r clf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

## Find overlaps of matches with peptides

Join the InterPro match table with the peptide and protein annotation tables (take the intersection with the annotation table, as the annotation table is the reference - peptides from SPACE):

```{r, include=T}
# Read in the table of proteins and peptides from SPACEmap CLF
peptide.table = read.delim("input/Crosslinked_fraction_CLF.tsv",
                           header = T,
                           sep = "\t",
                           stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                Gene.names,
                Protein.names)

# Read the table of proteins and peptides identified by SPACE
annot.table = read.delim("input/mES_enriched_SPACE.tsv",
                         header = T,
                         sep = "\t",
                         stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Category,
                RBP)

clf.ipr.matches.base = annot.table %>%
  left_join(clf.ipr.matches,
            by = c("Uniprot.ID" = "uniprot.id")) %>%
  left_join(peptide.table,
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  filter(!is.na(ipr.accession))
```

Now we have `r clf.ipr.matches.base %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.base %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered region matches in `r clf.ipr.matches.base %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins. The total number of peptides is `r clf.ipr.matches.base %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()`.

Originally, in the annotation table from SPACE, there were `r annot.table %>% filter(Category == "DB") %>% pull(Uniprot.ID) %>% unique() %>% length()` DNA-binding and `r annot.table %>% filter(RBP == "RBP") %>% pull(Uniprot.ID) %>% unique() %>% length()` RNA-binding proteins.

Next, take only domain and disordered region matches overlapping with the peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

clf.ipr.matches.overlap = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r clf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r clf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no father than 10 amino acids from them) from `r clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Generate SPACEmap vs SPACE stats

Calculate the proportion of shared matched peptides:

```{r, include=T}
space.proteins = annot.table %>%
  pull(Uniprot.ID) %>%
  unique()

spacemap.proteins = peptide.table %>%
  pull(Uniprot.ID) %>%
  unique()

sp.sp2.intersection.proteins = intersect(space.proteins, spacemap.proteins)

sp.sp2.intersection.peptides = peptide.table %>%
  # Take only shared proteins
  filter(Uniprot.ID %in% sp.sp2.intersection.proteins) %>%
  # Take all peptides from the shared proteins - these are shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

sp.sp2.intersection.peptides.matched = sp.sp2.intersection.peptides %>%
  # Determine which shared peptides are matched
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID",
                   "Sequence", 
                   "N.term.cleavage.window",
                   "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  # Take all matched shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()
```

Hence, the proportion of matched peptides in all shared peptides is `r nrow(sp.sp2.intersection.peptides.matched) / nrow(sp.sp2.intersection.peptides)`.

Write down the tables of shared peptides (all and matched):

```{r, include=T}
# Create the output directory, if it does not exist
dir.create("output")

# Load the table of peptides from SPACEmap for annotation purposes
peptide.table.whole = read.delim("input/Crosslinked_fraction_CLF.tsv",
                                 header = T,
                                 sep = "\t",
                                 stringsAsFactors = F)

# All shared peptides
write.table(sp.sp2.intersection.peptides %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_all.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Matched shared peptides
write.table(sp.sp2.intersection.peptides.matched %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_matched.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Select only DNA- and RNA-binding proteins

From the whole table, select only DNA- and RNA-binding proteins for further analysis:

```{r, include=T}
clf.ipr.matches.overlap.db_rbp = clf.ipr.matches.overlap %>%
  filter((Category == "DB") |
         (RBP == "RBP"))

write.table(clf.ipr.matches.overlap.db_rbp,
            "output/clf_matches_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

We have `r clf.ipr.matches.overlap.db_rbp %>% filter(Category == "DB") %>% pull(Uniprot.ID) %>% unique() %>% length()` DNA-binding proteins and `r clf.ipr.matches.overlap.db_rbp %>% filter(RBP == "RBP") %>% pull(Uniprot.ID) %>% unique() %>% length()` RNA-binding proteins (some of these proteins are DNA- and RNA-binding at the same time). In total, we lost `r (clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()) - (clf.ipr.matches.overlap.db_rbp %>%  pull(Uniprot.ID) %>% unique() %>% length())` as they are neither marked as DNA-binding nor as RNA-binding.

## Process matches in peptides from released fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the SPACEmap released fraction, also captured by SPACE (see `scan_rf.sh`).

Read and process the results of scanning of proteins enriched in the released fraction of SPACEmap and also in SPACE:

```{r, include=T}
# Read in the InterProScan results
rf.ipr.matches = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r rf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r rf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Next, retain only the peptides from the matched proteins that come from the released fraction and were identified by SPACE:

```{r, include=T}
peptide.table.rf = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.tsv",
                              header = T,
                              sep = "\t",
                              stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                Gene.names,
                Protein.names)

rf.ipr.matches.base = rf.ipr.matches %>%
  dplyr::rename(Uniprot.ID = uniprot.id) %>%
  left_join(peptide.table.rf,
            by = c("Uniprot.ID" = "Uniprot.ID"))
```

Now we have `r rf.ipr.matches.base %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.base %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered region matches in `r rf.ipr.matches.base %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins. The total number of peptides is `r rf.ipr.matches.base %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()`.

Next, take only domain and disordered region matches overlapping with the peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

rf.ipr.matches.overlap = rf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r rf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r rf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no father than 10 amino acids from them) from `r rf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Amino-acid frequencies in matched peptides

Calculate frequencies of amino acids from peptides matched in the crosslinked and released fractions. Do separate calculations for peptides matched to domains and to disordered regions (these two sets of peptides are overlapping, as one and the same peptide could match both to a domain and to a disordered region). Also, calculate frequencies of amino acids in matches in all peptides (the full proteome).

```{r, include=T}
aa.names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")

count_aas = function(aa.str) {
  aa.str.vec = strsplit(aa.str, "")[[1]]
  aa.counts = unlist(purrr::map(aa.names, 
                                function(x) {
                                  return(length(aa.str.vec[aa.str.vec == x]))
                                }))
  return(aa.counts)
}

# Frequencies of amino acids in domain-matching peptides from CLF
clf.ipr.matches.overlap.sequences.dom = clf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.clf.sum = sum(unique.aa.dict.dom.clf)
unique.aa.dict.dom.clf.freq = unlist(purrr::map(unique.aa.dict.dom.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.clf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from CLF
clf.ipr.matches.overlap.sequences.idr = clf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.clf.sum = sum(unique.aa.dict.idr.clf)
unique.aa.dict.idr.clf.freq = unlist(purrr::map(unique.aa.dict.idr.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.clf.sum
                                                }))

# Frequencies of amino acids in domain-matching peptides from RF
rf.ipr.matches.overlap.sequences.dom = rf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.rf.sum = sum(unique.aa.dict.dom.rf)
unique.aa.dict.dom.rf.freq = unlist(purrr::map(unique.aa.dict.dom.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.rf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from RF
rf.ipr.matches.overlap.sequences.idr = rf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.rf.sum = sum(unique.aa.dict.idr.rf)
unique.aa.dict.idr.rf.freq = unlist(purrr::map(unique.aa.dict.idr.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.rf.sum
                                                }))

# Table of the peptides from the full proteome
clf.peptides = annot.table %>%
  left_join(peptide.table, by = "Uniprot.ID") %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  filter(!is.na(Sequence)) %>%
  distinct()
rf.peptides = peptide.table.rf %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()
fp.peptides = clf.peptides %>%
  bind_rows(rf.peptides)

# Frequencies of amino acids in peptides from the full proteome (CLF + RF)
fp.sequences = fp.peptides %>%
  pull(Sequence)

unique.aa.dict.fp = count_aas(purrr::reduce(fp.sequences, paste0))
unique.aa.dict.fp.sum = sum(unique.aa.dict.fp)
unique.aa.dict.fp.freq = unlist(purrr::map(unique.aa.dict.fp, 
                                                function(x) {
                                                  x / unique.aa.dict.fp.sum
                                                }))
```

Plot the frequencies of amino acids from domain-matching peptides in CLF vs RF (Fig. 3E, left):

```{r, include=T}
# data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
#            rf = unique.aa.dict.dom.rf.freq * 100,
#            aa.names = aa.names) %>%
#   ggplot(aes(x = rf, y = clf, label = aa.names)) +
#     geom_point() +
#     geom_abline(slope = 1, intercept = 0) +
#     scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     ggrepel::geom_text_repel() +
#     theme_classic()
```

Plot the frequencies of amino acids from disordered region-matching peptides in CLF vs RF (Fig. 3E, right):

```{r, include=T}
# data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
#            rf = unique.aa.dict.idr.rf.freq * 100,
#            aa.names = aa.names) %>%
#   ggplot(aes(x = rf, y = clf, label = aa.names)) +
#     geom_point() +
#     geom_abline(slope = 1, intercept = 0) +
#     scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     ggrepel::geom_text_repel() +
#     theme_classic()
```

Plot the frequencies of amino acids in domain-matching peptides from CLF vs full proteome (Fig. S3F, left):

```{r, include=T}
# data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
#            fp = unique.aa.dict.fp.freq * 100,
#            aa.names = aa.names) %>%
#   ggplot(aes(x = fp, y = clf, label = aa.names)) +
#     geom_point() +
#     geom_abline(slope = 1, intercept = 0) +
#     scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     ggrepel::geom_text_repel() +
#     theme_classic()
```

Plot the frequencies of amino acids in disordered region-matching peptides in CLF vs full proteome (Fig. S3F, right):

```{r, include=T}
# data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
#            fp = unique.aa.dict.fp.freq * 100,
#            aa.names = aa.names) %>%
#   ggplot(aes(x = fp, y = clf, label = aa.names)) +
#     geom_point() +
#     geom_abline(slope = 1, intercept = 0) +
#     scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
#     ggrepel::geom_text_repel() +
#     theme_classic()
```

## Find the most frequent InterPro entries

Plot the frequencies of the top matched InterPro entries:

```{r, include=T, fig.height=8}
uniprotid.db.total.num = clf.ipr.matches.overlap.db_rbp %>% 
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.freq = clf.ipr.matches.overlap.db_rbp %>%
  group_by(ipr.accession) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

# clf.ipr.matches.overlap.db_rbp.freq %>%
#   filter(uniprotid.freq >= 0.01) %>%
#   mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
#   ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
#     geom_col(fill = "red") +
#     scale_y_continuous(limits = c(0, 0.5), breaks = pretty_breaks(n = 7)) +
#     theme_classic() +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the overall table of InterPro entry frequencies:

```{r, include=T}
write.table(clf.ipr.matches.overlap.db_rbp.freq,
            "output/clf_matches_in_db_and_rbp_freq.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Generalise (cluster) all matched InterPro entries

Do an automatical clusterisation of similar InterPro entries matched in SPACEmap CLF: If two InterPro entries co-match at least once and in >=70% of co-matches they overlap by >=70% of their lengths, reciprocally, then we put them in one cluster (generalised entry). To maintain clusters, we use disjoint set union:

```{r, include=T}
tic("Clusterisation of matched InterPro entries")

good_overlap_fraction_cutoff = 0.7

overlap_size_cutoff = 0.7

ipr_overlap_list = list()

iprs = c()

i_overlaps_j = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  return(min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1 > 0)
}

i_overlaps_j_well = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  overlap_size = min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1
  ipr_i_length = ipr_i_stop - ipr_i_start + 1
  ipr_j_length = ipr_j_stop - ipr_j_start + 1
  return((overlap_size >= overlap_size_cutoff * ipr_i_length) & 
         (overlap_size >= overlap_size_cutoff * ipr_j_length))
}

count_overlaps = function(gene_df) {
  gene_df = gene_df %>%
    dplyr::select(Uniprot.ID,
                  ipr.accession,
                  ipr.description,
                  int.start,
                  int.stop) %>%
    distinct()
  
  i = 0
  while (i < nrow(gene_df)) {
    i = i + 1
    ipr_i = as.character(gene_df[i, "ipr.accession"])
    ipr_i = ifelse(ipr_i == "", "disordered_region", ipr_i)
    iprs <<- c(iprs, ipr_i)
    j = i
    while (j < nrow(gene_df)) {
      j = j + 1
      ipr_j = as.character(gene_df[j, "ipr.accession"])
      ipr_j = ifelse(ipr_j == "", "disordered_region", ipr_j)
      iprs <<- c(iprs, ipr_j)
      if ((ipr_i != ipr_j) & (ipr_i != "disordered_region") & (ipr_j != "disordered_region")) {
        ipr_pair_name = paste0(ipr_i, "_", ipr_j)
        ipr_i_start = gene_df[i, "int.start"]
        ipr_i_stop = gene_df[i, "int.stop"]
        ipr_j_start = gene_df[j, "int.start"]
        ipr_j_stop = gene_df[j, "int.stop"]
        if (i_overlaps_j(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
          if (is.null(ipr_overlap_list[[ipr_pair_name]])) {
            ipr_overlap_list[[ipr_pair_name]] <<- list()
            ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- 0
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- 0
          }
          ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$all_overlaps + 1
          if (i_overlaps_j_well(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$good_overlaps + 1
          }
        }
      }
    }
  }
  iprs <<- unique(iprs)
}

# Form a list of overlapping IPR pairs
uniprot.ids = clf.ipr.matches.overlap.db_rbp %>%
  pull(Uniprot.ID) %>%
  unique()

for (uniprot.id in uniprot.ids) {
  count_overlaps(clf.ipr.matches.overlap.db_rbp %>% filter(Uniprot.ID == uniprot.id))
}

# Cluster InterPro entries by overlaps

# List to store disjoint sets
parent = list()

# List to store set ranks
set.size = list()

# DSU (Disjoint Set Union) functions
make_set = function(v) {
	parent[v] <<- v
	set.size[v] <<- 1
}

find_set = function(v) {
	if (v == unlist(parent[v])) {
	  return(v)
	}
	return(parent[v] <<- find_set(unlist(parent[v])))
}

merge_sets = function(a, b) {
	a = find_set(a)
	b = find_set(b)
	if (a != b) {
	  if (unlist(set.size[a]) > unlist(set.size[b])) {
	    parent[b] <<- a
	    set.size[a] <<- unlist(set.size[a]) + unlist(set.size[b])
	  } else {
	    parent[a] <<- b
	    set.size[b] <<- unlist(set.size[b]) + unlist(set.size[a])
	  }
	}
}

for (ipr in iprs) {
  make_set(ipr)
}

for (ipr_pair_name in names(ipr_overlap_list)) {
  if (ipr_overlap_list[[ipr_pair_name]]$good_overlaps / 
      ipr_overlap_list[[ipr_pair_name]]$all_overlaps >= 
      good_overlap_fraction_cutoff) {
    ipr_i = unlist(stringr::str_split(ipr_pair_name, "_"))[1]
    ipr_j = unlist(stringr::str_split(ipr_pair_name, "_"))[2]
    merge_sets(ipr_i, ipr_j)
  }
}

# Form the table of the found clusters
lead.ipr.table = data.frame(lead.ipr = unlist(parent),
                            ipr.accession = names(parent),
                            stringsAsFactors = F) %>%
  arrange(lead.ipr) %>%
  left_join(clf.ipr.matches.overlap.db_rbp %>%
              dplyr::select(ipr.accession,
                            ipr.description) %>%
              distinct(),
            by = c("ipr.accession"))

row.names(lead.ipr.table) = NULL

unique.lead.iprs = lead.ipr.table %>%
  pull(lead.ipr) %>%
  unique()

ipr.cluster.table = lead.ipr.table %>%
  left_join(data.frame(lead.ipr = unique.lead.iprs,
                       cluster.name = seq(1:length(unique.lead.iprs)),
                       stringsAsFactors = F),
            by = c("lead.ipr")) %>%
  dplyr::select(cluster.name,
                ipr.accession,
                ipr.description) %>%
  group_by(cluster.name) %>%
  mutate(cluster.size = length(ipr.accession)) %>%
  ungroup() %>%
  arrange(desc(cluster.size))

# Write down the table of all clusters
write.table(ipr.cluster.table,
            "output/match_clusters_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

toc()
# ~ 5 sec
```

Name clusters that are present in the plots below, according to the InterPro entries that these clusters contain:

```{r, include=T}
ipr.cluster.table = ipr.cluster.table %>%
  mutate(cluster.name = ifelse(cluster.name == "1", "Disordered region", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "481", "P-loop-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "592", "HTH", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "553", "RRM", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "293", "C2H2-type ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "265", "OB-fold", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "551", "RING/FYVE/PHD ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "51", "Helicase, C-terminal", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "342", "Armadillo-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "317", "DEAD-box-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "52", "WD40 repeat", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "510", "SAM methyltransferase-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "99", "KH domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "32", "MCM domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "580", "C2H2 ZF-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "588", "WD40-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "463", "WD40/YVTN-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "518", "MCM domain-containing", cluster.name))
```

## Find proportions of matched and unmatched CLF peptides from DNA- and RNA-binding proteins

First, find the number and proportion of all unmatched peptides from SPACEmap CLF:

```{r, include=T}
clf.matched.peptides = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.all.peptides = clf.ipr.matches.base %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.unmatched.peptides = clf.all.peptides %>%
  dplyr::anti_join(clf.matched.peptides,
                   by = c("Uniprot.ID" = "Uniprot.ID",
                          "Sequence" = "Sequence",
                          "N.term.cleavage.window" = "N.term.cleavage.window",
                          "C.term.cleavage.window" = "C.term.cleavage.window"))
```

Hence, we have `r nrow(clf.unmatched.peptides)` unmatched peptides from SPACEmap CLF (`r round(nrow(clf.unmatched.peptides) / nrow(clf.all.peptides) * 100, 1)`% of all peptides from SPACEmap CLF).

Secondly, calculate the proportion of unmatched CLF peptides from DNA- and RNA-binding proteins:

```{r, include=T}
clf.matched.peptides.dbp.n = clf.ipr.matches.base %>%
  filter(Category == "DB") %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.matched.peptides.rbp.n = clf.ipr.matches.base %>%
  filter(RBP == "RBP") %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.all.peptides.dbp.n = clf.ipr.matches.base %>%
  filter(Category == "DB") %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.all.peptides.rbp.n = clf.ipr.matches.base %>%
  filter(RBP == "RBP") %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.matched.peptides.dbp.freq = clf.matched.peptides.dbp.n / clf.all.peptides.dbp.n

clf.matched.peptides.rbp.freq = clf.matched.peptides.rbp.n / clf.all.peptides.rbp.n

clf.unmatched.peptides.dbp.freq = 1 - clf.matched.peptides.dbp.freq

clf.unmatched.peptides.rbp.freq = 1 - clf.matched.peptides.rbp.freq

data.frame(protein.category = c("DBP", "DBP", "RBP", "RBP"),
           peptide.category = c("Matched", "Unmatched", "Matched", "Unmatched"),
           peptide.frequency = c(clf.matched.peptides.dbp.freq,
                                 clf.unmatched.peptides.dbp.freq,
                                 clf.matched.peptides.rbp.freq,
                                 clf.unmatched.peptides.rbp.freq)) %>%
  ggplot(aes(x = protein.category, y = peptide.frequency)) +
    geom_col(aes(fill = peptide.category)) +
    #scale_y_continuous(limits = c(0, 0.5), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

So, the vast majority of peptides in both protein groups are matched, and the unmatched fractions are comparable.

## Find frequencies of cluster matches

First, apply our clusterisation to the main table with matched CLf peptides from DNA- and RNA-binding proteins:

```{r, include=T}
clf.ipr.matches.overlap.db_rbp.collated = clf.ipr.matches.overlap.db_rbp %>%
  mutate(ipr.accession = ifelse(ipr.accession == "", "disordered_region", ipr.accession)) %>%
  mutate(ipr.description = ifelse(ipr.description == "", "disordered_region", ipr.description)) %>%
  left_join(ipr.cluster.table %>%
              mutate(ipr.description = ifelse(is.na(ipr.description), "disordered_region", ipr.description)),
            by = c("ipr.accession", "ipr.description")) %>%
  filter(!is.na(cluster.name)) %>%
  mutate(ipr.accession = "") %>%
  mutate(ipr.description = cluster.name)
```

Secondly, generate tables with the frequencies of proteins and peptides with different matches (plot top 10 by frequency).

For the DNA-binding proteins (Fig. S3E, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(Category == "DB") %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.collated.db_freq = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(Category == "DB") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.db) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.db_freq,
            "output/clf_db_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# clf.ipr.matches.overlap.db_rbp.collated.db_freq %>%
#   head(10) %>%
#   mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
#   mutate(uniprotid.freq = uniprotid.freq * 100) %>%
#   ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
#     geom_col(fill = "dark green") +
#     scale_y_continuous(limits = c(0, 60), breaks = pretty_breaks(n = 7)) +
#     theme_classic() +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the RNA-binding proteins (Fig. 3D; Fig. S3D, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.rbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

write.table(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq,
            "output/clf_rbp_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# clf.ipr.matches.overlap.db_rbp.collated.rbp_freq %>%
#   head(10) %>%
#   mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
#   mutate(uniprotid.freq = uniprotid.freq * 100) %>%
#   ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
#     geom_col(fill = "purple") +
#     scale_y_continuous(limits = c(0, 50), breaks = pretty_breaks(n = 7)) +
#     theme_classic() +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from DNA-binding proteins (Fig. S3E, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db.peptides = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(Category == "DB") %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(Category == "DB") %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.db.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides,
            "output/clf_db_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides %>%
#   head(10) %>%
#   mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
#   mutate(peptide.id.freq = peptide.id.freq * 100) %>%
#   ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
#     geom_col(fill = "dark green") +
#     scale_y_continuous(limits = c(0, 40), breaks = pretty_breaks(n = 5)) +
#     theme_classic() +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from RNA-binding proteins (Fig. S3D, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp.peptides = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.rbp.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides,
            "output/clf_rbp_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides %>%
#   head(10) %>%
#   mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
#   mutate(peptide.id.freq = peptide.id.freq * 100) %>%
#   ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
#     geom_col(fill = "purple") +
#     scale_y_continuous(limits = c(0, 30), breaks = pretty_breaks(n = 5)) +
#     theme_classic() +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the table of generalised entries:

```{r, include=T}
write.table(ipr.cluster.table,
            "output/cluster_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Compare amino acid frequencies in IDRs from DNA- and RNA-binding proteins

Compare amino acids from IDR matches in peptides from DNA- and RNA-binding proteins:

```{r, include=T}
# Frequencies of amino acids in disordered region-matching peptides from DNA-binding proteins in CLF 
clf.ipr.matches.overlap.db.sequences.idr = clf.ipr.matches.overlap.db_rbp %>%
  filter(Category == "DB") %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.db.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.db.sequences.idr, paste0))
unique.aa.dict.idr.db.clf.sum = sum(unique.aa.dict.idr.db.clf)
unique.aa.dict.idr.db.clf.freq = unlist(purrr::map(unique.aa.dict.idr.db.clf, 
                                                   function(x) {
                                                     x / unique.aa.dict.idr.db.clf.sum
                                                   }))

# Frequencies of amino acids in disordered region-matching peptides from RNA-binding proteins in CLF 
clf.ipr.matches.overlap.rbp.sequences.idr = clf.ipr.matches.overlap.db_rbp %>%
  filter(RBP == "RBP") %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.rbp.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.rbp.sequences.idr, paste0))
unique.aa.dict.idr.rbp.clf.sum = sum(unique.aa.dict.idr.rbp.clf)
unique.aa.dict.idr.rbp.clf.freq = unlist(purrr::map(unique.aa.dict.idr.rbp.clf, 
                                                   function(x) {
                                                     x / unique.aa.dict.idr.rbp.clf.sum
                                                   }))
```

Plot the frequencies of amino acids in disordered region-matching peptides in DBPs vs RBPs:

```{r, include=T}
data.frame(dbp = unique.aa.dict.idr.db.clf.freq * 100,
           rbp = unique.aa.dict.idr.rbp.clf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = dbp, y = rbp, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Hence, IDRs from RBPs tend to contain more alanine (A) and glutamic acid (E), while IDRs in DBPs tend to have more proline (P) and serine (S).

## Compare top structural domain types in DNA- and RNA-binding proteins

Take top 5 structural domain types (the general clusters that we found above) in DNA- and RNA-binding proteins and compare their abundance in both groups:

```{r, include=T}
# Select top 5 matched domain types from DBPs and RBPs, and merge these domain types in one set
# Let us exclude disordered region matches as here we are interested in domains
top.matched.domains = unique(c(clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides %>%
                                 arrange(desc(peptide.id.freq)) %>%
                                 head(6) %>% # 5 without IDRs
                                 pull(ipr.description),
                               clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides %>%
                                 arrange(desc(peptide.id.freq)) %>%
                                 head(6) %>% # 5 without IDRs
                                 pull(ipr.description)))

freq.in.dbp_rbp = clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides %>%
  filter(ipr.description %in% top.matched.domains) %>%
  dplyr::rename("peptide.id.n.dbp" = "peptide.id.n",
                "peptide.id.freq.dbp" = "peptide.id.freq") %>%
  dplyr::select(-ipr.accession) %>%
  dplyr::full_join(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides %>%
                     filter(ipr.description %in% top.matched.domains) %>%
                     dplyr::rename("peptide.id.n.rbp" = "peptide.id.n",
                                   "peptide.id.freq.rbp" = "peptide.id.freq") %>%
                     dplyr::select(-ipr.accession),
                   by = c("ipr.description" = "ipr.description")) %>%
  tidyr::replace_na(list(peptide.id.n.dbp = 0, 
                         peptide.id.freq.dbp = 0,
                         peptide.id.n.rbp = 0,
                         peptide.id.freq.rbp = 0)) %>%
  arrange(desc(peptide.id.freq.dbp)) %>%
  filter(ipr.description != "Disordered region")

top.matched.domains.ordered = freq.in.dbp_rbp$ipr.description

# Plot the top 5 matched domain types, sorted by decreasing abundance in DBPs
data.frame(domain.type = rep(top.matched.domains.ordered, 2),
           protein.category = c(rep("DBP", length(top.matched.domains.ordered)), 
                                rep("RBP", length(top.matched.domains.ordered))),
           peptide.freq = c(freq.in.dbp_rbp$peptide.id.freq.dbp,
                            freq.in.dbp_rbp$peptide.id.freq.rbp)) %>%
  mutate(domain.type = factor(domain.type, levels = top.matched.domains.ordered)) %>%
  mutate(peptide.freq = peptide.freq * 100) %>%
  ggplot(aes(x = domain.type, y = peptide.freq)) +
    geom_col(aes(fill = protein.category), position = "dodge2") +
    scale_y_continuous(limits = c(0, 12), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```
...

Hence, the P-loop-related domain structures are equally frequent in DBPs and RBPs, which matches previously published results ([Romero et al., 2018](https://www.pnas.org/content/115/51/E11943)). 

RRM is more abundant in RBPs than in DBPs, which corresponds to its definition as an RNA recognition motif. However, its abundance in DBPs is comparable, which matches the known ability of RRM to bind both RNA and ssDNA ().

---

Overall, looking at the protein-level figure, panel C, disordered regions are more frequent in DNA-binding than in RNA-binding proteins. Winged-helix, C2H2 zinc finger, and SANT/Myb domain-like matches are also more frequent in the DNA-binding proteins, which could make sense, as domains of these types are very widespread in transcription factors in general, but Im not sure how abundant they could be in RNA-binding proteins. Interestingly, RING/FYVE/PHD zinc finger domains are more frequent in the DNA-binding proteins, although these types of zinc fingers are not usually considered to be DNA-binding (see, for example, IPR001965 for PHD and IPR011011 for FYVE). However, this general entry also contains the extended PHD (ePHD) which is known to be able to bind double-stranded DNA (see IPR034732). Surprisingly, the OB fold-like general entry is also more frequent in the DNA-binding proteins, although its comprising specific entries look more like RNA-binding (domains from different ribosomal proteins; S1 domain is thought to be RNA-binding: IPR003029). On the other hand, it also contains the cold shock domain which is known to bind DNA (see IPR002059) and, according to InterPro, is very similar to the RNA-binding S1 domain. So, this OB-fold structure should allow both DNA- and RNA-binding.

In contrast, RRM and Armadillo fold-related domains are much more frequent in RNA-binding proteins. RRM is an RNA-binding domain by definition, and the Armadillo fold is a very general type of protein structure which, according to InterPro, has an extensive solvent-accessible surface that is well suited to binding large substrates such as proteins and nucleic acids. Furthermore, many of the specific entries from this general entry are indeed related to RNA metabolism: (1) the W2 domain (IPR003307) and the MIF4G domains (see, for example, IPR003890) come from translation factors (and MIF4G is also known to function in the nonsense-mediated mRNA decay); (2) DNA polymerase V/Myb-binding protein 1A (IPR007015) and Nucleolar pre-ribosomal-associated protein 1, C-terminal domain (IPR032436) localise to nucleolus where rRNA is produced; (3) Pumilio homology domain (IPR033133) is a known RNA-binding domain.

---

## Study unmatched CLF peptides from SPACEmap

Unmatched CLF peptides from SPACEmap may have motifs representing as yet undiscovered domains. Let us scan the unmatched peptide sequences with MeMe. For this, we need to prepare the sequences first: (a) merge N- and C-terminal flanks with the peptide sequences by overlaps (so that if a motif goes into flanks, it would be captured); (b) merge the combined sequences from the same protein by overlaps (we want to avoid a situation when a motif is deemed significant just because it is constructed from overlapping peptide sequences); (c) filter out sequences that are shorter than 8 amino acids (MEME's threshold for sequence length). Let us prepare the sequences:

```{r, include=T}
# Merge two strings by an overlap or concatenate them if there is no overlap
str_merge = function(str1, str2) {
  if ((str1 == "") & (str2 == "")) {
    return("")
  }
  if (str1 == "") {
    return(str2)
  }
  if (str2 == "") {
    return(str1)
  }
  if (stringr::str_detect(str1, fixed(str2))) {
    return(str1)
  }
  if (stringr::str_detect(str2, fixed(str1))) {
    return(str2)
  }
  str1_length = nchar(str1)
  str2_length = nchar(str2)
  max_prefix_coordinate = 0
  for (i in seq(0, min(str1_length, str2_length) - 1)) {
    if (substr(str1, str1_length - i, str1_length) == substr(str2, 1, i + 1)) {
      max_prefix_coordinate = i + 1
    }
  }
  if (max_prefix_coordinate == 0) {
    return(paste0(str1, str2))
  }
  return(paste0(str1, substr(str2, max_prefix_coordinate + 1, str2_length)))
}

# Assemble sequences by overlaps
calc_str_merge = function(str1, str2) {
  if (stringr::str_detect(str1, fixed(str2))) {
    return(list("length" = nchar(str2),
                "merge" = str1))
  }
  if (stringr::str_detect(str2, fixed(str1))) {
    return(list("length" = nchar(str1),
                "merge" = str2))
  }
  str1_length = nchar(str1)
  str2_length = nchar(str2)
  max_prefix_coordinate = 0
  for (i in seq(0, min(str1_length, str2_length) - 1)) {
    if (substr(str1, str1_length - i, str1_length) == substr(str2, 1, i + 1)) {
      max_prefix_coordinate = i + 1
    }
  }
  return(list("length" = max_prefix_coordinate,
              "merge" = paste0(str1, substr(str2, max_prefix_coordinate + 1, str2_length))))
}

merge_sequences = function(sequence.lead, sequence.lag) {
  merge.list.lead.lag = calc_str_merge(sequence.lead, sequence.lag)
  merge.list.lag.lead = calc_str_merge(sequence.lag, sequence.lead)
  if (merge.list.lead.lag[["length"]] >= merge.list.lag.lead[["length"]]) {
    return(merge.list.lead.lag)
  }
  return(merge.list.lag.lead)
}

assemble_by_overlaps = function(uniprotid,
                                input.sequences) {
  if (length(input.sequences) == 1) {
    return(data.frame(Uniprot.ID = uniprotid, 
                      contigs = input.sequences[1], 
                      status = "original",
                      stringsAsFactors = F))
  }
  overlap.size.cutoff = 5
  sequences.to.assemble = input.sequences
  contigs.to.report = c()
  status.list = list()
  for (input.sequence in input.sequences) {
    status.list[[input.sequence]] = "original"
  }
  contig.status.list = list()
  while (length(sequences.to.assemble) > 1) {
    cat("=========\n")
    cat("sequences.to.assemble:\n")
    cat(sequences.to.assemble, "\n")
    sequence.lead = sequences.to.assemble[1]
    cat("sequence.lead: ", sequence.lead, "\n")
    max.overlap.length = 0
    max.overlap.index = 0
    max.overlap.sequence.lag = ""
    max.overlap.merge = ""
    cat(uniprotid, "\n")
    for (lag.i in 2:(length(sequences.to.assemble))) {
      sequence.lag = sequences.to.assemble[lag.i]
      cat("sequence.lag: ", sequence.lag, "\n")
      merge.list = merge_sequences(sequence.lead, sequence.lag)
      cat("merge.list: ")
      str(merge.list)
      cat("\n")
      overlap.length = merge.list[["length"]]
      overlap.merge = merge.list[["merge"]]
      cat("overlap.length: ")
      str(overlap.length)
      cat("\n")
      cat("overlap.merge: ")
      str(overlap.merge)
      cat("\n")
      if (overlap.length > max.overlap.length) {
        max.overlap.length = overlap.length
        max.overlap.index = lag.i
        max.overlap.sequence.lag = sequence.lag
        max.overlap.merge = overlap.merge
      }
    }
    if (max.overlap.length >= overlap.size.cutoff) {
      sequences.to.assemble = sequences.to.assemble[-max.overlap.index]
      status.list[[max.overlap.sequence.lag]] = NULL
      sequences.to.assemble = sequences.to.assemble[-1]
      status.list[[sequence.lead]] = NULL
      sequences.to.assemble[length(sequences.to.assemble) + 1] = max.overlap.merge
      status.list[[max.overlap.merge]] = "merged"
    } else {
      sequences.to.assemble = sequences.to.assemble[-1]
      contigs.to.report[length(contigs.to.report) + 1] = sequence.lead
      contig.status.list[length(contig.status.list) + 1] = status.list[[sequence.lead]]
      status.list[[sequence.lead]] = NULL
    }
  }
  contigs.to.report[length(contigs.to.report) + 1] = sequences.to.assemble[1]
  contig.status.list[length(contig.status.list) + 1] = status.list[1]
  
  return(data.frame(Uniprot.ID = rep(uniprotid, length(sequences.to.assemble)), 
                    contigs = contigs.to.report, #sequences.to.assemble, 
                    status = unlist(contig.status.list), #unlist(status.list),
                    stringsAsFactors = F))
}

# Just one sequence
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL"),
#                                                Uniprot.ID = rep("A2A3V1", 1),
#                                                stringsAsFactors = F)

# No overlaps between two sequences
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL",
#                                                                     "TRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR"),
#                                                Uniprot.ID = rep("A2A3V1", 2),
#                                                stringsAsFactors = F)

# Overlap is not long enough => no overlap detected
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL",
#                                                                     "EESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR"),
#                                                Uniprot.ID = rep("A2A3V1", 2),
#                                                stringsAsFactors = F)

# Overlap of two sequences
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL",
#                                                                     "SLSEEESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR"),
#                                                Uniprot.ID = rep("A2A3V1", 2),
#                                                stringsAsFactors = F)

# No overlaps in three sequences
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("HLTSTCQWQRDVYAKGDGFQIYLRKQGYHS",
#                                                                     "SLSEEESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR",
#                                                                     "SLTTRKRTTAVYYNNN"),
#                                                Uniprot.ID = rep("A2A3V1", 3),
#                                                stringsAsFactors = F)

# Overlap of three sequences
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL",
#                                                                     "SLSEEESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR",
#                                                                     "MPSMPPKRARSLTTRKRTTAVYYNNN"),
#                                                Uniprot.ID = rep("A2A3V1", 3),
#                                                stringsAsFactors = F)

# Overlap of two sequences out of three
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL",
#                                                                     "SLSEEESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR",
#                                                                     "SLTTRKRTTAVYYNNN"),
#                                                Uniprot.ID = rep("A2A3V1", 3),
#                                                stringsAsFactors = F)

# Overlaps: (2, 4, 1), (3, 5); 6 does not overlap with any other sequence
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("MPSMPPKRARSLTTRKRTTAVYYNNN",
#                                                                     "HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL",
#                                                                     "AAGNNYHRTHADEEF",
#                                                                     "SLSEEESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR",
#                                                                     "THADEEFTRRGHTRTHGR",
#                                                                     "YYYNNTGTFGTNNNYYY"),
#                                                Uniprot.ID = rep("A2A3V1", 6),
#                                                stringsAsFactors = F)

# Overlaps: (2, 4, 1); 3 does not overlap with any other sequence
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("MPSMPPKRARSLTTRKRTTAVYYNNN",
#                                                                     "HLTSTCQWQRDVYAKGDGFQIYLRKQGYHSNSLSEEESL",
#                                                                     "AAGNNYHRTHADEEF",
#                                                                     "SLSEEESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR"),
#                                                Uniprot.ID = rep("A2A3V1", 4),
#                                                stringsAsFactors = F)

# Overlaps: (3, 1); (2, 4)
# unmatched.peptides.remainder.test = data.frame(peptide.sequence = c("MPSMPPKRARSLTTRKRTTAVYYNNN",
#                                                                     "AAGNNYHRTHADEEF",
#                                                                     "SLSEEESLSTTRKKRRLTSGMFDQNVKYRPLHMPSMPPKRAR",
#                                                                     "THADEEFTRRGHTRTHGR"),
#                                                Uniprot.ID = rep("A2A3V1", 4),
#                                                stringsAsFactors = F)

unmatched.remainder.crosslinked.test = dplyr::bind_rows(purrr::map(unmatched.peptides.remainder.test %>%
                                                                pull(Uniprot.ID) %>%
                                                                unique(),
                                                              function(uniprotid) {
                                                                assemble_by_overlaps(uniprotid,
                                                                                     unmatched.peptides.remainder.test %>%
                                                                                       filter(Uniprot.ID == uniprotid) %>%
                                                                                       pull(peptide.sequence))
                                                              }))
unmatched.remainder.crosslinked.test

#   group_by(Uniprot.ID,
#            Sequence,
#            N.term.cleavage.window,
#            C.term.cleavage.window) %>%
#   do(mutate(., peptide.sequence = str_merge(
#                                     str_merge(
#                                       stringr::str_replace_all(.$N.term.cleavage.window, "_", ""),
#                                       stringr::str_replace_all(.$Sequence, "_", "")),
#                                     stringr::str_replace_all(.$C.term.cleavage.window, "_", "")))) %>%
#   ungroup()
```
