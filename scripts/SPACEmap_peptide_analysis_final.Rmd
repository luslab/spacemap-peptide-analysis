---
title: "Analysis of the data from the SPACEmap experiment"
author: "Sviatoslav Sidorov"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
   html_document:
     code_folding: hide
     collapsed: no
     fig_align: center
     fig_caption: yes
     highlight: haddock
     keep_md: yes
     number_sections: yes
     smooth_scroll: no
     toc: yes
     toc_depth: 3
     toc_float: yes
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/rstudio") # Please change to a dir where you have the input subdir
knitr::opts_chunk$set(echo = TRUE)
stringsAsFactors = F

library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(tibble)
library(ggplot2)
library(ggrepel)
library(kableExtra)
library(scales)
library(tictoc)
library(seqinr)
```

## Obtain the table of InterPro matches in peptides from crosslinked fraction

Using InterProScan, we scanned all proteins containing at least one peptide from the crosslinked fraction (see `scan_clf.sh`).

Upload and filter the scan results; calculate integrated coordinates of the matches:

```{r, include=T}
signature.overlap.fraction = 0.7

find_consensus_matches = function(start, stop) {
  df = data.frame(int.start.cons = start,
                  int.stop.cons = stop,
                  stringsAsFactors = F)
  
  i = 1
  while (i <= nrow(df)) {
    start.i = df[i, ]$int.start.cons
    stop.i = df[i, ]$int.stop.cons
    j = i + 1
    while (j <= nrow(df)) {
      start.j = df[j, ]$int.start.cons
      stop.j = df[j, ]$int.stop.cons
      i.length = stop.i - start.i + 1
      j.length = stop.j - start.j + 1
      i.j.overlap.size = min(stop.i, stop.j) - max(start.i, start.j) + 1
      if ((i.j.overlap.size > signature.overlap.fraction * i.length) | 
          (i.j.overlap.size > signature.overlap.fraction * j.length)) {
        new.start.cons = min(start.i, start.j)
        new.stop.cons = max(stop.i, stop.j)
        old.start.cons.i = df[i, ]$int.start.cons
        old.stop.cons.i = df[i, ]$int.stop.cons
        df[i, ]$int.start.cons = new.start.cons
        df[i, ]$int.stop.cons = new.stop.cons
        start.i = new.start.cons
        stop.i = new.stop.cons
        df[j, ]$int.start.cons = new.start.cons
        df[j, ]$int.stop.cons = new.stop.cons
      }
      j = j + 1
    }
    i = i + 1
  }
  
  return(df %>% 
           dplyr::select(int.start.cons,
                         int.stop.cons))
    
}

# Read the InterProScan results
clf.ipr.matches = read.delim("input/SPACEmap_crosslinked_fraction_overlap_with_SPACE_protein.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r clf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r clf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Define functions to plot InterPro scan results for a protein by UniProt ID:

```{r, include=T}
generate_protein_df = function(UniProtId) {
  return(read.delim("input/SPACEmap_crosslinked_fraction_overlap_with_SPACE_protein.fa.tsv",
                    header = F,
                    colClasses = c("character",
                                   "character",
                                   "numeric",
                                   "character",
                                   "character",
                                   "character",
                                   "numeric",
                                   "numeric",
                                   "character",
                                   "character",
                                   "character",
                                   "character",
                                   "character"),
                    col.names = c("seq.id",
                                  "md5",
                                  "seq.length",
                                  "db",
                                  "signature.accession",
                                  "signature.description",
                                  "start",
                                  "stop",
                                  "score",
                                  "status",
                                  "date",
                                  "ipr.accession",
                                  "ipr.description")) %>%
         filter(status == "T") %>%
         # Parse the protein sequence headers and take the Uniprot IDs
         group_by(seq.id) %>%
         mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
         ungroup() %>%
         filter(uniprot.id == UniProtId))
}

preprocess_protein_df = function(protein.df) {
  c = 10 # vertical space between InterPro entries
  h = 5  # height of a match rectangle
  d = 5  # vertical space between rectangles
  
  protein.df = protein.df %>%
    dplyr::select(seq.length,
                  signature.accession,
                  uniprot.id,
                  start,
                  stop,
                  ipr.accession) %>%
    dplyr::rename(length = seq.length,
                           db.accession = signature.accession) %>%
    arrange(desc(start), desc(stop))
  
  ipr.numbers = unique(protein.df$ipr.accession)
  ipr.numbers = ipr.numbers[ipr.numbers != ""]
  ipr.numbers = c(ipr.numbers, "")
  names(ipr.numbers) = as.character(1:(length(ipr.numbers)))
  
  protein.df = protein.df %>%
    rowwise() %>%
    mutate(ipr.n = as.numeric(names(ipr.numbers[ipr.numbers == ipr.accession]))) %>%
    arrange(ipr.n) %>%
    rownames_to_column(var = "row.n") %>%
    mutate(row.n = as.numeric(row.n)) %>%
    mutate(ymin = ipr.n * c + (row.n - 1) * (h + d)) %>%
    mutate(ymax = ymin + h)
  
  return(protein.df)
}

generate_ipr_df = function(protein.df) {
  ipr.label.shift.x = -10
  ipr.label.shift.y = 5
  return(protein.df %>%
         dplyr::select(ipr.accession,
                       start,
                       stop,
                       ymax) %>%
         group_by(ipr.accession) %>%
         do(mutate(., ipr.x = (min(.$start) + max(.$stop)) / 2 + ipr.label.shift.x)) %>%
         do(mutate(., ipr.y = max(.$ymax) + ipr.label.shift.y)) %>%
         ungroup() %>%
         dplyr::select(ipr.accession,
                       ipr.x,
                       ipr.y) %>%
         distinct())
}

draw_matches = function(uniprot.id) {
  signature.label.shift.x = 30
  label.font.size = 3
  x.axis.extension = 50
  
  protein.df = generate_protein_df(uniprot.id)
  
  protein.df = preprocess_protein_df(protein.df)
  
  ipr.df = generate_ipr_df(protein.df)
  
  p = ggplot(protein.df) +
    # Matches
    geom_rect(mapping = aes(xmin = start,
                            xmax = stop,
                            ymin = ymin,
                            ymax = ymax,
                            fill = db.accession)) +
    # Signature IDs
    geom_text(aes(x = stop + signature.label.shift.x,
                  y = (ymin + ymax) / 2,
                  label = db.accession),
              size = label.font.size) +
    # InterPro IDs
    geom_text(data = ipr.df,
              aes(x = ipr.x,
                  y = ipr.y,
                  label = ipr.accession),
              size = label.font.size) +
    # Protein C-terminal mark
    geom_vline(xintercept = unlist(protein.df[1, "length"])) + 
    # Ruler
    scale_x_continuous(n.breaks = 7, 
                       limits = c(0, unlist(protein.df[1, "length"]) + x.axis.extension)) +
    # Formatting
    theme_classic() + 
    theme(axis.line.y = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.x = element_blank(),
          legend.position="none")
  
  ggsave("output/plots/Fig_S4F_draft_all_matches.pdf",
         p)
}
```

Print an example of scanning results from InterProScan (draft of the starting plot of Supplementary Fig. 4F):

```{r}
# Create output/plots dir if it does not exist; print a warning and do nothing if it already exists
dir.create(file.path("output", "plots"))

# Plot the draft of Supplementary Fig. 4F (starting plot) and save it into output/plots
draw_matches("A2A4P0")
```

## Find overlaps of matches with peptides from crosslinked fraction

Join the InterPro match table with the CLF peptide table (prepare a table to find overlaps between CLF peptides and InterProScan entry matches):

```{r, include=T}
# Load the table of proteins and peptides from SPACEmap CLF intersected with SPACE
peptide.table = read.delim("input/SPACEmap_crosslinked_fraction_overlap_with_SPACE.tsv",
                           header = T,
                           sep = "\t",
                           stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names,
                Category,
                RBP)

clf.ipr.matches.base = clf.ipr.matches %>%
  left_join(peptide.table,
            by = c("uniprot.id" = "Uniprot.ID"))
```

Next, take only domain and disordered region matches that overlap with the CLF peptides or reside no farther than 10 amino acids from them on either side:

```{r, include=T}
match.vicinity = 10 # amino acids

clf.ipr.matches.overlap = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Define functions for drawing peptide matches:

```{r, include=T}
draw_peptides = function(UniProtId) {
  x.axis.extension = 50
  y.axis.extension = 100
  ymin.const = 5
  ymax.const = 10
  
  protein.df = clf.ipr.matches.overlap %>%
    filter(uniprot.id == UniProtId) %>%
    dplyr::select(Sequence,
                  N.term.cleavage.window,
                  C.term.cleavage.window,
                  Start.position,
                  End.position) %>%
    mutate(ymin = ymin.const,
           ymax = ymax.const)
  
  protein.length = read.delim("input/SPACEmap_crosslinked_fraction_overlap_with_SPACE_protein.fa.tsv",
                              header = F,
                              colClasses = c("character",
                                             "character",
                                             "numeric",
                                             "character",
                                             "character",
                                             "character",
                                             "numeric",
                                             "numeric",
                                             "character",
                                             "character",
                                             "character",
                                             "character",
                                             "character"),
                              col.names = c("seq.id",
                                            "md5",
                                            "seq.length",
                                            "db",
                                            "signature.accession",
                                            "signature.description",
                                            "start",
                                            "stop",
                                            "score",
                                            "status",
                                            "date",
                                            "ipr.accession",
                                            "ipr.description")) %>%
    filter(status == "T") %>%
    # Select domains that are integrated into InterPro (ipr.accession != "") and 
    # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
    filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
    # Parse the protein sequence headers and take the Uniprot IDs
    group_by(seq.id) %>%
    mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
    ungroup() %>%
    filter(uniprot.id == UniProtId) %>%
    pull(seq.length) %>%
    unique()
  
  p = ggplot(protein.df) +
    # Matches
    geom_rect(mapping = aes(xmin = Start.position,
                            xmax = End.position,
                            ymin = ymin,
                            ymax = ymax)) +
    # Protein C-terminal mark
    geom_vline(xintercept = protein.length) + 
    # Ruler
    scale_x_continuous(n.breaks = 7, 
                       limits = c(0, protein.length + x.axis.extension)) +
    # y scale
    scale_y_continuous(limits = c(0, ymax.const + y.axis.extension)) + 
    # Formatting
    theme_classic() + 
    theme(axis.line.y = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.x = element_blank(),
          legend.position="none")
  
    ggsave("output/plots/Fig_S4G_draft_peptides.pdf",
           p)
}
```

Draw matches for the example protein (A2A4P0):

```{r, include=T}
draw_peptides("A2A4P0")
```

Now we have `r clf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(uniprot.id, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(uniprot.id, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r clf.ipr.matches.overlap %>% dplyr::select(uniprot.id, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` CLF peptides (or residing no farther than 10 amino acids from them on either side) from `r clf.ipr.matches.overlap %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

## Generate SPACEmap-CLF vs SPACE stats

Calculate the numbers of proteins for the Venn diagram in Fig. 4B:

```{r, include=T}
# All proteins from the SPACE experiment
space.proteins = read.delim("input/SPACE.tsv", 
                            header = T,
                            sep = "\t",
                            stringsAsFactors = F) %>%
  pull(Uniprot.ID) %>%
  unique()

# All proteins from the crosslinked fraction of the SPACEmap experiment
spacemap.proteins = read.delim("input/SPACEmap_crosslinked_revised.tsv", 
                               header = T,
                               sep = "\t",
                               stringsAsFactors = F) %>%
  pull(Uniprot.ID) %>%
  unique()

sp.sp2.intersection.proteins.from_table = read.delim("input/SPACEmap_crosslinked_fraction_overlap_with_SPACE.tsv",
                                                     header = T,
                                                     sep = "\t",
                                                     stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID) %>%
  arrange(Uniprot.ID) %>%
  pull(Uniprot.ID) %>%
  unique()

cat("The number of proteins shared between SPACE and SPACEmap CLF:", 
    length(sp.sp2.intersection.proteins.from_table), "\n")
cat("The number of proteins unique to SPACE:",
    length(setdiff(space.proteins, sp.sp2.intersection.proteins.from_table)), "\n")
cat("The number of proteins unique to SPACEmap CLF:",
    length(setdiff(spacemap.proteins, sp.sp2.intersection.proteins.from_table)))
```

Calculate the number of peptides shared by SPACE and SPACEmap CLF (Fig. 4B):

```{r, include=T}
sp.sp2.intersection.peptides = read.delim("input/SPACEmap_crosslinked_fraction_overlap_with_SPACE.tsv",
                                           header = T,
                                           sep = "\t",
                                           stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

cat("The number of peptides shared by SPACE and SPACEmap CLF:", 
    nrow(sp.sp2.intersection.peptides), "\n")
```

Calculate the number and proportion of matched shared peptides for Fig. 4B (upper bar):

```{r, include=T}
sp.sp2.intersection.peptides.matched = sp.sp2.intersection.peptides %>%
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID" = "uniprot.id",
                   "Sequence" = "Sequence", 
                   "N.term.cleavage.window" = "N.term.cleavage.window",
                   "C.term.cleavage.window" = "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

p = data.frame(feature = c(rep("Peptides", 2)),
               peptide.category = c("Matched", "Unmatched"),
               fraction = c(nrow(sp.sp2.intersection.peptides.matched) / nrow(sp.sp2.intersection.peptides),
                            (nrow(sp.sp2.intersection.peptides) - nrow(sp.sp2.intersection.peptides.matched)) /
                              nrow(sp.sp2.intersection.peptides))) %>%
  mutate(peptide.category = factor(peptide.category, levels = rev(peptide.category))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = peptide.category)) +
    theme_classic()

ggsave("output/plots/Fig_4B_upper_bar.pdf",
       p,
       width = 3,
       height = 6)

cat("The number of matched shared peptides:", 
    nrow(sp.sp2.intersection.peptides.matched), "\n")
cat("The percentage of matched shared peptides among all shared peptides:",
    nrow(sp.sp2.intersection.peptides.matched) / nrow(sp.sp2.intersection.peptides) * 100, "%\n")
```

Stratify all matched shared peptides into those matched to domains, to IDRs or to both types of regions (Fig. 4B, lower bar):

```{r, include=T}
sp.sp2.intersection.peptides.matched.bytype = sp.sp2.intersection.peptides %>%
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID" = "uniprot.id",
                   "Sequence" = "Sequence", 
                   "N.term.cleavage.window" = "N.term.cleavage.window",
                   "C.term.cleavage.window" = "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window,
                ipr.accession) %>%
  distinct() %>%
  mutate(region.type = ifelse(ipr.accession == "", "IDR", "Domain")) %>%
  dplyr::select(-ipr.accession) %>%
  distinct() %>%
  group_by(Uniprot.ID,
           Sequence, 
           N.term.cleavage.window,
           C.term.cleavage.window) %>%
  mutate(region.type.final = ifelse(("Domain" %in% region.type) & 
                                    ("IDR" %in% region.type), 
                                    "Both", 
                                    region.type)) %>%
  ungroup() %>%
  dplyr::select(-region.type) %>%
  distinct()

domain.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  filter(region.type.final == "Domain") %>%
  nrow()

idr.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  filter(region.type.final == "IDR") %>%
  nrow()

both.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  filter(region.type.final == "Both") %>%
  nrow()

all.matches.n = sp.sp2.intersection.peptides.matched.bytype %>%
  nrow()

p = data.frame(feature = c(rep("Peptides", 3)),
           region.type = c("Domain", "IDR", "Both"),
           fraction = c(domain.matches.n / all.matches.n,
                        idr.matches.n / all.matches.n,
                        both.matches.n / all.matches.n)) %>%
  mutate(region.type = factor(region.type, levels = rev(region.type))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = region.type)) +
    theme_classic()

ggsave("output/plots/Fig_4B_lower_bar.pdf",
       p,
       width = 3,
       height = 6)

cat("The percentage of peptides with domain matches:",
    domain.matches.n / all.matches.n * 100, "%\n")
cat("The percentage of peptides with IDR matches:",
    idr.matches.n / all.matches.n * 100, "%\n")
cat("The percentage of peptides with both domain and IDR matches:",
    both.matches.n / all.matches.n * 100, "%\n")
```

Write down the table of matched shared CLF peptides (Supplementary Table 2, spreadsheet "Peptides mapped to a region"):

```{r, include=T}
# Create output/tables dir if it does not exist; print a warning and do nothing if it already exists
dir.create(file.path("output", "tables"))

# Load the table of peptides from SPACEmap CLF and SPACE for annotation purposes
peptide.table.whole = read.delim("input/SPACEmap_crosslinked_fraction_overlap_with_SPACE.tsv",
                                 header = T,
                                 sep = "\t",
                                 stringsAsFactors = F)

# Matched shared peptides
write.table(sp.sp2.intersection.peptides.matched %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID" = "Uniprot.ID",
                               "Sequence" = "Sequence", 
                               "N.term.cleavage.window" = "N.term.cleavage.window",
                               "C.term.cleavage.window" = "C.term.cleavage.window")) %>%
              dplyr::select(Sequence,
                            Gene.names,
                            Uniprot.ID,
                            Start.position,
                            End.position,
                            logFC,
                            P.Value,
                            adj.P.Val,
                            Protein.names,
                            PEP,
                            Intensity.CLF_R1,
                            Intensity.CLF_R2,
                            Intensity.CLF_R3,
                            Intensity.RF_R1,
                            Intensity.RF_R2,
                            Intensity.RF_R3) %>%
              arrange(Sequence),
            "output/tables/Supplementary_Table2_Peptides_mapped_to_a_region.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Write down the table of matched shared peptides with matches for each of the peptides (Supplementary Table 2, spreadsheet "SPACEmap-crosslinked peptides"):

```{r, include=T}
calc_overlap_category = function(row.df) {
  Start.position = row.df[1, "Start.position"]
  End.position = row.df[1, "End.position"]
  int.start = row.df[1, "int.start"]
  int.stop = row.df[1, "int.stop"]
  if ((Start.position <= int.start) & (End.position >= int.stop) | 
      (Start.position > int.start) & (End.position < int.stop)) {
    return("Complete overlap")
  } else if ((Start.position < int.start) & (End.position >= int.start)) {
    return("Partial overlap (left boundary)")
  } else if ((Start.position <= int.stop) & (End.position > int.stop)) {
    return("Partial overlap (right boundary)")
  } else { # We apply this function only to peptide-match overlaps,
           # so if there is no actual overlap, then a peptide and a match 
           # are no farther than 10 aa apart
    return("<= 10 a.a. away from the region")
  }
}

# Matched shared peptides with the match info
clf.ipr.matches.overlap.categories = clf.ipr.matches.overlap %>%
  group_by(uniprot.id,
           Sequence,
           N.term.cleavage.window,
           C.term.cleavage.window,
           int.start,
           int.stop,
           Start.position,
           End.position) %>%
  do(mutate(., overlap.category = calc_overlap_category(.))) %>%
  ungroup() %>%
  dplyr::select(Gene.names,
                Protein.names,
                uniprot.id,
                Sequence,
                Start.position,
                End.position,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description,
                overlap.category,
                Category,
                RBP) %>%
  dplyr::rename("Peptide.start" = "Start.position",
                "Peptide.stop" = "End.position",
                "Match.start" = "int.start",
                "Match.stop" = "int.stop",
                "InterPro.accession" = "ipr.accession",
                "InterPro.description" = "ipr.description",
                "Peptide.match.overlap" = "overlap.category") %>%
  arrange(Gene.names,
          Protein.names,
          Sequence,
          Peptide.start,
          Peptide.stop,
          Match.start,
          Match.stop) %>%
  mutate(InterPro.description = ifelse(InterPro.description == "",
                                       "Disordered region",
                                       InterPro.description))

write.table(clf.ipr.matches.overlap.categories,
            "output/tables/Supplementary_Table2_SPACEmap-crosslinked_peptides.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Select only matched chromatin- and RNA-binding CLF proteins

From the whole table of shared CLF proteins, select only matched chromatin-binding proteins (CBPs) and RNA-binding proteins (RBPs) for further analysis:

```{r, include=T}
clf.ipr.matches.overlap.cbp_rbp = clf.ipr.matches.overlap %>%
  filter((Category == "DNA.Chromatin.binder") | (RBP == "RBP"))
```

We have `r clf.ipr.matches.overlap.cbp_rbp %>% filter(Category == "DNA.Chromatin.binder") %>% pull(uniprot.id) %>% unique() %>% length()` matched shared CBPs and `r clf.ipr.matches.overlap.cbp_rbp %>% filter(RBP == "RBP") %>% pull(uniprot.id) %>% unique() %>% length()` matched shared RBPs (some of these proteins are CBPs and RBPs at the same time). In total, we lost `r (clf.ipr.matches.overlap %>% pull(uniprot.id) %>% unique() %>% length()) - (clf.ipr.matches.overlap.cbp_rbp %>%  pull(uniprot.id) %>% unique() %>% length())` matched proteins as they are neither marked as CBPs nor as RBPs.

## Process matches in peptides from released fraction

Using InterProScan, we scanned all proteins captured by SPACE and also containing at least one peptide from the SPACEmap released fraction (see `scan_rf.sh`). Load the scanning results:

```{r, include=T}
# Load the InterProScan results
rf.ipr.matches = read.delim("input/SPACEmap_released_fraction_overlap_with_SPACE_protein.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r rf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r rf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Join the InterPro match table for the released fraction with the peptide table for the same fraction (prepare a table to find overlaps between. peptides and matches):

```{r, include=T}
peptide.table.rf = read.delim("input/SPACEmap_released_fraction_overlap_with_SPACE.tsv",
                              header = T,
                              sep = "\t",
                              stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names)

rf.ipr.matches.base = rf.ipr.matches %>%
  dplyr::rename(Uniprot.ID = uniprot.id) %>%
  left_join(peptide.table.rf,
            by = c("Uniprot.ID" = "Uniprot.ID"))
```

Next, only take matches that overlap with a shared released peptide or reside no farther than 10 amino acids either side of it:

```{r, include=T}
match.vicinity = 10 # amino acids

rf.ipr.matches.overlap = rf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r rf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r rf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` shared released peptides (or residing no father than 10 amino acids either side of them) from `r rf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Amino-acid frequencies in matched peptides

Calculate frequencies of amino acids from peptides matched in the crosslinked and released fractions. Do separate calculations for peptides matched to domains and to disordered regions (these two sets of peptides may overlap, as one and the same peptide may match both to a domain and to a disordered region). Also, calculate frequencies of amino acids in matches in all peptides (the full proteome).

```{r, include=T}
aa.names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")

count_aas = function(aa.str) {
  aa.str.vec = strsplit(aa.str, "")[[1]]
  aa.counts = unlist(purrr::map(aa.names, 
                                function(x) {
                                  return(length(aa.str.vec[aa.str.vec == x]))
                                }))
  return(aa.counts)
}

# Frequencies of amino acids in domain-matching peptides from CLF
clf.ipr.matches.overlap.sequences.dom = clf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(uniprot.id,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.clf.sum = sum(unique.aa.dict.dom.clf)
unique.aa.dict.dom.clf.freq = unlist(purrr::map(unique.aa.dict.dom.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.clf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from CLF
clf.ipr.matches.overlap.sequences.idr = clf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(uniprot.id,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.clf.sum = sum(unique.aa.dict.idr.clf)
unique.aa.dict.idr.clf.freq = unlist(purrr::map(unique.aa.dict.idr.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.clf.sum
                                                }))

# Frequencies of amino acids in domain-matching peptides from RF
rf.ipr.matches.overlap.sequences.dom = rf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.rf.sum = sum(unique.aa.dict.dom.rf)
unique.aa.dict.dom.rf.freq = unlist(purrr::map(unique.aa.dict.dom.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.rf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from RF
rf.ipr.matches.overlap.sequences.idr = rf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.rf.sum = sum(unique.aa.dict.idr.rf)
unique.aa.dict.idr.rf.freq = unlist(purrr::map(unique.aa.dict.idr.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.rf.sum
                                                }))

clf.peptides = peptide.table %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

rf.peptides = peptide.table.rf %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

fp.peptides = clf.peptides %>%
  bind_rows(rf.peptides)

# Frequencies of amino acids in peptides from the full proteome (CLF + RF)
fp.sequences = fp.peptides %>%
  pull(Sequence)

unique.aa.dict.fp = count_aas(purrr::reduce(fp.sequences, paste0))
unique.aa.dict.fp.sum = sum(unique.aa.dict.fp)
unique.aa.dict.fp.freq = unlist(purrr::map(unique.aa.dict.fp, 
                                                function(x) {
                                                  x / unique.aa.dict.fp.sum
                                                }))
```

Plot the frequencies of amino acids from domain-matching peptides in CLF vs RF (Fig. 4F, left):

```{r, include=T}
p = data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           rf = unique.aa.dict.dom.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()

ggsave("output/plots/Fig_4F_left.pdf",
       p,
       width = 3,
       height = 3)
```

Plot the frequencies of amino acids from disordered region-matching peptides in CLF vs RF (Fig. 4G, left):

```{r, include=T}
p = data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           rf = unique.aa.dict.idr.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()

ggsave("output/plots/Fig_4G_left.pdf",
       p,
       width = 3,
       height = 3)
```

Plot the frequencies of amino acids in domain-matching peptides from CLF vs frequencies in the full proteome (Fig. 4F, right):

```{r, include=T}
p = data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()

ggsave("output/plots/Fig_4F_right.pdf",
       p,
       width = 3,
       height = 3)
```

Plot the frequencies of amino acids in disordered region-matching peptides in CLF vs frequencies in the full proteome (Fig. 4G, right):

```{r, include=T}
p = data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 14), breaks = pretty_breaks(n = 14), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()

ggsave("output/plots/Fig_4G_right.pdf",
       p,
       width = 3,
       height = 3)
```

## Generalise (cluster) all matched InterPro entries

Do an automatical clusterisation of similar InterPro entries matched in CLF peptides (from CBPs and RBPs) shared between SPACEmap and SPACE: If two InterPro entries co-match at least once and in >=70% of co-matches they overlap by >=70% of their lengths, reciprocally, then we put them in one cluster (generalised entry). To maintain clusters, we implement disjoint set union:

```{r, include=T}
tic("Clusterisation of matched InterPro entries")

good_overlap_fraction_cutoff = 0.7

overlap_size_cutoff = 0.7

ipr_overlap_list = list()

iprs = c()

i_overlaps_j = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  return(min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1 > 0)
}

i_overlaps_j_well = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  overlap_size = min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1
  ipr_i_length = ipr_i_stop - ipr_i_start + 1
  ipr_j_length = ipr_j_stop - ipr_j_start + 1
  return((overlap_size >= overlap_size_cutoff * ipr_i_length) & 
         (overlap_size >= overlap_size_cutoff * ipr_j_length))
}

count_overlaps = function(gene_df) {
  gene_df = gene_df %>%
    dplyr::select(uniprot.id,
                  ipr.accession,
                  ipr.description,
                  int.start,
                  int.stop) %>%
    distinct()
  
  i = 0
  while (i < nrow(gene_df)) {
    i = i + 1
    ipr_i = as.character(gene_df[i, "ipr.accession"])
    ipr_i = ifelse(ipr_i == "", "disordered_region", ipr_i)
    iprs <<- c(iprs, ipr_i)
    j = i
    while (j < nrow(gene_df)) {
      j = j + 1
      ipr_j = as.character(gene_df[j, "ipr.accession"])
      ipr_j = ifelse(ipr_j == "", "disordered_region", ipr_j)
      iprs <<- c(iprs, ipr_j)
      if ((ipr_i != ipr_j) & (ipr_i != "disordered_region") & (ipr_j != "disordered_region")) {
        ipr_pair_name = paste0(ipr_i, "_", ipr_j)
        ipr_i_start = gene_df[i, "int.start"]
        ipr_i_stop = gene_df[i, "int.stop"]
        ipr_j_start = gene_df[j, "int.start"]
        ipr_j_stop = gene_df[j, "int.stop"]
        if (i_overlaps_j(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
          if (is.null(ipr_overlap_list[[ipr_pair_name]])) {
            ipr_overlap_list[[ipr_pair_name]] <<- list()
            ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- 0
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- 0
          }
          ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$all_overlaps + 1
          if (i_overlaps_j_well(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$good_overlaps + 1
          }
        }
      }
    }
  }
  iprs <<- unique(iprs)
}

# Form a list of overlapping IPR pairs
uniprot.ids = clf.ipr.matches.overlap.cbp_rbp %>%
  pull(uniprot.id) %>%
  unique()

for (uniprot.id.var in uniprot.ids) {
  count_overlaps(clf.ipr.matches.overlap.cbp_rbp %>% filter(uniprot.id == uniprot.id.var))
}

# Cluster InterPro entries by overlaps

# List to store disjoint sets
parent = list()

# List to store set ranks
set.size = list()

# DSU (Disjoint Set Union) functions
make_set = function(v) {
	parent[v] <<- v
	set.size[v] <<- 1
}

find_set = function(v) {
	if (v == unlist(parent[v])) {
	  return(v)
	}
	return(parent[v] <<- find_set(unlist(parent[v])))
}

merge_sets = function(a, b) {
	a = find_set(a)
	b = find_set(b)
	if (a != b) {
	  if (unlist(set.size[a]) > unlist(set.size[b])) {
	    parent[b] <<- a
	    set.size[a] <<- unlist(set.size[a]) + unlist(set.size[b])
	  } else {
	    parent[a] <<- b
	    set.size[b] <<- unlist(set.size[b]) + unlist(set.size[a])
	  }
	}
}

for (ipr in iprs) {
  make_set(ipr)
}

for (ipr_pair_name in names(ipr_overlap_list)) {
  if (ipr_overlap_list[[ipr_pair_name]]$good_overlaps / 
      ipr_overlap_list[[ipr_pair_name]]$all_overlaps >= 
      good_overlap_fraction_cutoff) {
    ipr_i = unlist(stringr::str_split(ipr_pair_name, "_"))[1]
    ipr_j = unlist(stringr::str_split(ipr_pair_name, "_"))[2]
    merge_sets(ipr_i, ipr_j)
  }
}

# Form the table of the found clusters
lead.ipr.table = data.frame(lead.ipr = unlist(parent),
                            ipr.accession = names(parent),
                            stringsAsFactors = F) %>%
  arrange(lead.ipr) %>%
  left_join(clf.ipr.matches.overlap.cbp_rbp %>%
              dplyr::select(ipr.accession,
                            ipr.description) %>%
              distinct(),
            by = c("ipr.accession"))

row.names(lead.ipr.table) = NULL

unique.lead.iprs = lead.ipr.table %>%
  pull(lead.ipr) %>%
  unique()

ipr.cluster.table = lead.ipr.table %>%
  left_join(data.frame(lead.ipr = unique.lead.iprs,
                       cluster.name = seq(1:length(unique.lead.iprs)),
                       stringsAsFactors = F),
            by = c("lead.ipr")) %>%
  dplyr::select(cluster.name,
                ipr.accession,
                ipr.description) %>%
  group_by(cluster.name) %>%
  mutate(cluster.size = length(ipr.accession)) %>%
  ungroup() %>%
  arrange(desc(cluster.size))

toc()
```

Name clusters that are present in the plots below according to the InterPro entries that these clusters contain. Write down the table of all clusters (Supplementary Table 2, spreadsheet "Clustered domains"):

```{r, include=T}
ipr.cluster.table = ipr.cluster.table %>%
  mutate(cluster.name = ifelse(cluster.name == "1",   "Disordered region", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "515", "P-loop-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "649", "HTH", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "607", "RRM", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "301", "C2H2-type ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "270", "OB-fold", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "48",  "Helicase, C-terminal", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "356", "Armadillo-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "720", "DEAD-box-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "49",  "WD40 repeat", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "549", "SAM methyltransferase-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "380", "WD40-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "524", "WD40/YVTN-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "566", "MCM protein", cluster.name))

# Write down the table of all clusters
write.table(ipr.cluster.table,
            "output/tables/Supplementary_Table2_Clustered_domains.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Find frequencies of cluster matches

First, apply our clusterisation to the main table with matched CLF peptides from CBPs and RBPs:

```{r, include=T}
clf.ipr.matches.overlap.cbp_rbp.collated = clf.ipr.matches.overlap.cbp_rbp %>%
  mutate(ipr.accession = ifelse(ipr.accession == "", "disordered_region", ipr.accession)) %>%
  mutate(ipr.description = ifelse(ipr.description == "", "disordered_region", ipr.description)) %>%
  left_join(ipr.cluster.table %>%
              mutate(ipr.description = ifelse(is.na(ipr.description), "disordered_region", ipr.description)),
            by = c("ipr.accession", "ipr.description")) %>%
  mutate(ipr.accession = "") %>%
  mutate(ipr.description = cluster.name)
```

Secondly, generate tables with the frequencies of proteins and peptides with different generalised matches (to plot top 10 generalised matches by frequency).

For CBPs (Fig. 4E; Fig. S4E, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.cbp = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(Category == "DNA.Chromatin.binder") %>%
  pull(uniprot.id) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(Category == "DNA.Chromatin.binder") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(uniprot.id))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.cbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct()

p = clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 60), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

ggsave("output/plots/Fig_4E_S4E-left.pdf",
       p)
```

For the RBPs (Fig. 4D; Fig. S4D, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  pull(uniprot.id) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(uniprot.id))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.rbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

p = clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 50), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

ggsave("output/plots/Fig_4D_S4D-left.pdf",
       p)
```

For the peptides from CBPs (Fig. S4E, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(Category == "DNA.Chromatin.binder") %>% 
  dplyr::select(uniprot.id,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(Category == "DNA.Chromatin.binder") %>%
  group_by(uniprot.id, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(uniprot.id, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.db.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

p = clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 40), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

ggsave("output/plots/Fig_S4E-right.pdf",
       p)
```

For the peptides from RBPs (Fig. S4D, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  dplyr::select(uniprot.id,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(uniprot.id, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(uniprot.id, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.rbp.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

p = clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 30), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

ggsave("output/plots/Fig_S4D-right.pdf",
       p)
```

`r uniprotid.db.total.num.collated.cbp / (peptide.table %>% filter(Category == "DNA.Chromatin.binder") %>% pull(Uniprot.ID) %>% unique() %>% length()) * 100`% of CBPs and `r uniprotid.db.total.num.collated.rbp / (peptide.table %>% filter(RBP == "RBP") %>% pull(Uniprot.ID) %>% unique() %>% length()) * 100`% of RBPs match to a domain or an IDR.

