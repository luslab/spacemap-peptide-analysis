---
title: "Analysis of the crosslinked and released fractions of peptides from SPACEmap"
author: "Sviatoslav Sidorov"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
   html_document:
     code_folding: hide
     collapsed: no
     fig_align: center
     fig_caption: yes
     highlight: haddock
     keep_md: yes
     number_sections: yes
     smooth_scroll: no
     toc: yes
     toc_depth: 3
     toc_float: yes
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/rstudio") # Please change to yours
#opts_knit$set(root.dir = "/Volumes/lab-luscomben/home/users/sidoros/projects/spacemap-peptide-analysis") 
knitr::opts_chunk$set(echo = TRUE)
stringsAsFactors = F

library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(tibble)
library(ggplot2)
library(ggrepel)
dyn.load("/home/rstudio/libs/libicudata.so.67")
dyn.load("/home/rstudio/libs/libicuuc.so.67")
dyn.load("/home/rstudio/libs/libxml2.so.2")
dyn.load("/home/rstudio/libs/libiconv.so.2")
library(kableExtra)
library(scales)
library(tictoc)
library(seqinr)
```

## Obtain the table of InterPro matches in peptides from crosslinked fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the crosslinked fraction (see `scan_clf.sh`).

Upload and filter the scan results; calculate integrated coordinates of the matches:

```{r, include=T}
signature.overlap.fraction = 0.7

find_consensus_matches = function(start, stop) {
  df = data.frame(int.start.cons = start,
                  int.stop.cons = stop,
                  stringsAsFactors = F)
  
  i = 1
  while (i <= nrow(df)) {
    start.i = df[i, ]$int.start.cons
    stop.i = df[i, ]$int.stop.cons
    j = i + 1
    while (j <= nrow(df)) {
      start.j = df[j, ]$int.start.cons
      stop.j = df[j, ]$int.stop.cons
      i.length = stop.i - start.i + 1
      j.length = stop.j - start.j + 1
      i.j.overlap.size = min(stop.i, stop.j) - max(start.i, start.j) + 1
      if ((i.j.overlap.size > signature.overlap.fraction * i.length) | 
          (i.j.overlap.size > signature.overlap.fraction * j.length)) {
        new.start.cons = min(start.i, start.j)
        new.stop.cons = max(stop.i, stop.j)
        old.start.cons.i = df[i, ]$int.start.cons
        old.stop.cons.i = df[i, ]$int.stop.cons
        df[i, ]$int.start.cons = new.start.cons
        df[i, ]$int.stop.cons = new.stop.cons
        start.i = new.start.cons
        stop.i = new.stop.cons
        df[j, ]$int.start.cons = new.start.cons
        df[j, ]$int.stop.cons = new.stop.cons
      }
      j = j + 1
    }
    i = i + 1
  }
  
  return(df %>% 
           dplyr::select(int.start.cons,
                         int.stop.cons))
    
}

# Read the InterProScan results
clf.ipr.matches = read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r clf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r clf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

## Find overlaps of matches with peptides

Join the InterPro match table with the peptide and protein annotation tables (take the intersection with the annotation table, as the annotation table is the reference - peptides from SPACE):

```{r, include=T}
# Read in the table of proteins and peptides from SPACEmap CLF
peptide.table = read.delim("input/Crosslinked_fraction_CLF.tsv",
                           header = T,
                           sep = "\t",
                           stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names)

# Read the table of proteins and peptides identified by SPACE
annot.table = read.delim("input/mES_enriched_SPACE.tsv",
                         header = T,
                         sep = "\t",
                         stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Category,
                RBP)

clf.ipr.matches.base = annot.table %>%
  left_join(clf.ipr.matches,
            by = c("Uniprot.ID" = "uniprot.id")) %>%
  left_join(peptide.table,
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  filter(!is.na(ipr.accession))
```

Now we have `r clf.ipr.matches.base %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.base %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered region matches in `r clf.ipr.matches.base %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins. The total number of peptides is `r clf.ipr.matches.base %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()`.

Originally, in the annotation table from SPACE, there were `r annot.table %>% filter(Category == "DB") %>% pull(Uniprot.ID) %>% unique() %>% length()` DNA-binding and `r annot.table %>% filter(RBP == "RBP") %>% pull(Uniprot.ID) %>% unique() %>% length()` RNA-binding proteins.

Next, take only domain and disordered region matches overlapping with the peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

clf.ipr.matches.overlap = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r clf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r clf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no father than 10 amino acids from them) from `r clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Generate SPACEmap vs SPACE stats

Calculate the proportion of shared matched peptides:

```{r, include=T}
space.proteins = annot.table %>%
  pull(Uniprot.ID) %>%
  unique()

spacemap.proteins = peptide.table %>%
  pull(Uniprot.ID) %>%
  unique()

sp.sp2.intersection.proteins = intersect(space.proteins, spacemap.proteins)

sp.sp2.intersection.peptides = peptide.table %>%
  # Take only shared proteins
  filter(Uniprot.ID %in% sp.sp2.intersection.proteins) %>%
  # Take all peptides from the shared proteins - these are shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

sp.sp2.intersection.peptides.matched = sp.sp2.intersection.peptides %>%
  # Determine which shared peptides are matched
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID",
                   "Sequence", 
                   "N.term.cleavage.window",
                   "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  # Take all matched shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()
```

Hence, the proportion of matched peptides in all shared proteins is `r nrow(sp.sp2.intersection.peptides.matched) / nrow(sp.sp2.intersection.peptides)`.

Write down the tables of shared peptides (all and matched):

```{r, include=T}
# Create the output directory, if it does not exist
dir.create("output")

# Load the table of peptides from SPACEmap for annotation purposes
peptide.table.whole = read.delim("input/Crosslinked_fraction_CLF.tsv",
                                 header = T,
                                 sep = "\t",
                                 stringsAsFactors = F)

# All shared peptides
write.table(sp.sp2.intersection.peptides %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_all.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Matched shared peptides
write.table(sp.sp2.intersection.peptides.matched %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_matched.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Select only DNA- and RNA-binding proteins

From the whole table, select only DNA- and RNA-binding proteins for further analysis:

```{r, include=T}
clf.ipr.matches.overlap.db_rbp = clf.ipr.matches.overlap %>%
  filter((Category == "DB") |
         (RBP == "RBP"))

write.table(clf.ipr.matches.overlap.db_rbp,
            "output/clf_matches_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

We have `r clf.ipr.matches.overlap.db_rbp %>% filter(Category == "DB") %>% pull(Uniprot.ID) %>% unique() %>% length()` DNA-binding proteins and `r clf.ipr.matches.overlap.db_rbp %>% filter(RBP == "RBP") %>% pull(Uniprot.ID) %>% unique() %>% length()` RNA-binding proteins (some of these proteins are DNA- and RNA-binding at the same time). In total, we lost `r (clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()) - (clf.ipr.matches.overlap.db_rbp %>%  pull(Uniprot.ID) %>% unique() %>% length())` as they are neither marked as DNA-binding nor as RNA-binding.

## Process matches in peptides from released fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the SPACEmap released fraction, also captured by SPACE (see `scan_rf.sh`).

Read and process the results of scanning of proteins enriched in the released fraction of SPACEmap and also in SPACE:

```{r, include=T}
# Read in the InterProScan results
rf.ipr.matches = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r rf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r rf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Next, retain only the peptides from the matched proteins that come from the released fraction and were identified by SPACE:

```{r, include=T}
peptide.table.rf = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.tsv",
                              header = T,
                              sep = "\t",
                              stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names)

rf.ipr.matches.base = rf.ipr.matches %>%
  dplyr::rename(Uniprot.ID = uniprot.id) %>%
  left_join(peptide.table.rf,
            by = c("Uniprot.ID" = "Uniprot.ID"))
```

Now we have `r rf.ipr.matches.base %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.base %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered region matches in `r rf.ipr.matches.base %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins. The total number of peptides is `r rf.ipr.matches.base %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()`.

Next, take only domain and disordered region matches overlapping with the peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

rf.ipr.matches.overlap = rf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r rf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r rf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no father than 10 amino acids from them) from `r rf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Amino-acid frequencies in matched peptides

Calculate frequencies of amino acids from peptides matched in the crosslinked and released fractions. Do separate calculations for peptides matched to domains and to disordered regions (these two sets of peptides are overlapping, as one and the same peptide could match both to a domain and to a disordered region). Also, calculate frequencies of amino acids in matches in all peptides (the full proteome).

```{r, include=T}
aa.names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")

count_aas = function(aa.str) {
  aa.str.vec = strsplit(aa.str, "")[[1]]
  aa.counts = unlist(purrr::map(aa.names, 
                                function(x) {
                                  return(length(aa.str.vec[aa.str.vec == x]))
                                }))
  return(aa.counts)
}

# Frequencies of amino acids in domain-matching peptides from CLF
clf.ipr.matches.overlap.sequences.dom = clf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.clf.sum = sum(unique.aa.dict.dom.clf)
unique.aa.dict.dom.clf.freq = unlist(purrr::map(unique.aa.dict.dom.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.clf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from CLF
clf.ipr.matches.overlap.sequences.idr = clf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.clf.sum = sum(unique.aa.dict.idr.clf)
unique.aa.dict.idr.clf.freq = unlist(purrr::map(unique.aa.dict.idr.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.clf.sum
                                                }))

# Frequencies of amino acids in domain-matching peptides from RF
rf.ipr.matches.overlap.sequences.dom = rf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.rf.sum = sum(unique.aa.dict.dom.rf)
unique.aa.dict.dom.rf.freq = unlist(purrr::map(unique.aa.dict.dom.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.rf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from RF
rf.ipr.matches.overlap.sequences.idr = rf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.rf.sum = sum(unique.aa.dict.idr.rf)
unique.aa.dict.idr.rf.freq = unlist(purrr::map(unique.aa.dict.idr.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.rf.sum
                                                }))

# Table of the peptides from the full proteome
clf.peptides = annot.table %>%
  left_join(peptide.table, by = "Uniprot.ID") %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  filter(!is.na(Sequence)) %>%
  distinct()
rf.peptides = peptide.table.rf %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()
fp.peptides = clf.peptides %>%
  bind_rows(rf.peptides)

# Frequencies of amino acids in peptides from the full proteome (CLF + RF)
fp.sequences = fp.peptides %>%
  pull(Sequence)

unique.aa.dict.fp = count_aas(purrr::reduce(fp.sequences, paste0))
unique.aa.dict.fp.sum = sum(unique.aa.dict.fp)
unique.aa.dict.fp.freq = unlist(purrr::map(unique.aa.dict.fp, 
                                                function(x) {
                                                  x / unique.aa.dict.fp.sum
                                                }))
```

Plot the frequencies of amino acids from domain-matching peptides in CLF vs RF (Fig. 3F, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           rf = unique.aa.dict.dom.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids from disordered region-matching peptides in CLF vs RF (Fig. 3G, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           rf = unique.aa.dict.idr.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in domain-matching peptides from CLF vs full proteome (Fig. 3F, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in disordered region-matching peptides in CLF vs full proteome (Fig. 3G, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

## Find the most frequent InterPro entries

Plot the frequencies of the top matched InterPro entries:

```{r, include=T, fig.height=8}
uniprotid.db.total.num = clf.ipr.matches.overlap.db_rbp %>% 
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.freq = clf.ipr.matches.overlap.db_rbp %>%
  group_by(ipr.accession) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

clf.ipr.matches.overlap.db_rbp.freq %>%
  filter(uniprotid.freq >= 0.01) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "red") +
    scale_y_continuous(limits = c(0, 0.5), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the overall table of InterPro entry frequencies:

```{r, include=T}
write.table(clf.ipr.matches.overlap.db_rbp.freq,
            "output/clf_matches_in_db_and_rbp_freq.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Generalise (cluster) all matched InterPro entries

Do an automatical clusterisation of similar InterPro entries matched in CLF peptides (from DBPs and RBPs) shared between SPACEmap and SPACE: If two InterPro entries co-match at least once and in >=70% of co-matches they overlap by >=70% of their lengths, reciprocally, then we put them in one cluster (generalised entry). To maintain clusters, we use disjoint set union:

```{r, include=T}
tic("Clusterisation of matched InterPro entries")

good_overlap_fraction_cutoff = 0.7

overlap_size_cutoff = 0.7

ipr_overlap_list = list()

iprs = c()

i_overlaps_j = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  return(min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1 > 0)
}

i_overlaps_j_well = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  overlap_size = min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1
  ipr_i_length = ipr_i_stop - ipr_i_start + 1
  ipr_j_length = ipr_j_stop - ipr_j_start + 1
  return((overlap_size >= overlap_size_cutoff * ipr_i_length) & 
         (overlap_size >= overlap_size_cutoff * ipr_j_length))
}

count_overlaps = function(gene_df) {
  gene_df = gene_df %>%
    dplyr::select(Uniprot.ID,
                  ipr.accession,
                  ipr.description,
                  int.start,
                  int.stop) %>%
    distinct()
  
  i = 0
  while (i < nrow(gene_df)) {
    i = i + 1
    ipr_i = as.character(gene_df[i, "ipr.accession"])
    ipr_i = ifelse(ipr_i == "", "disordered_region", ipr_i)
    iprs <<- c(iprs, ipr_i)
    j = i
    while (j < nrow(gene_df)) {
      j = j + 1
      ipr_j = as.character(gene_df[j, "ipr.accession"])
      ipr_j = ifelse(ipr_j == "", "disordered_region", ipr_j)
      iprs <<- c(iprs, ipr_j)
      if ((ipr_i != ipr_j) & (ipr_i != "disordered_region") & (ipr_j != "disordered_region")) {
        ipr_pair_name = paste0(ipr_i, "_", ipr_j)
        ipr_i_start = gene_df[i, "int.start"]
        ipr_i_stop = gene_df[i, "int.stop"]
        ipr_j_start = gene_df[j, "int.start"]
        ipr_j_stop = gene_df[j, "int.stop"]
        if (i_overlaps_j(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
          if (is.null(ipr_overlap_list[[ipr_pair_name]])) {
            ipr_overlap_list[[ipr_pair_name]] <<- list()
            ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- 0
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- 0
          }
          ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$all_overlaps + 1
          if (i_overlaps_j_well(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$good_overlaps + 1
          }
        }
      }
    }
  }
  iprs <<- unique(iprs)
}

# Form a list of overlapping IPR pairs
uniprot.ids = clf.ipr.matches.overlap.db_rbp %>%
  pull(Uniprot.ID) %>%
  unique()

for (uniprot.id in uniprot.ids) {
  count_overlaps(clf.ipr.matches.overlap.db_rbp %>% filter(Uniprot.ID == uniprot.id))
}

# Cluster InterPro entries by overlaps

# List to store disjoint sets
parent = list()

# List to store set ranks
set.size = list()

# DSU (Disjoint Set Union) functions
make_set = function(v) {
	parent[v] <<- v
	set.size[v] <<- 1
}

find_set = function(v) {
	if (v == unlist(parent[v])) {
	  return(v)
	}
	return(parent[v] <<- find_set(unlist(parent[v])))
}

merge_sets = function(a, b) {
	a = find_set(a)
	b = find_set(b)
	if (a != b) {
	  if (unlist(set.size[a]) > unlist(set.size[b])) {
	    parent[b] <<- a
	    set.size[a] <<- unlist(set.size[a]) + unlist(set.size[b])
	  } else {
	    parent[a] <<- b
	    set.size[b] <<- unlist(set.size[b]) + unlist(set.size[a])
	  }
	}
}

for (ipr in iprs) {
  make_set(ipr)
}

for (ipr_pair_name in names(ipr_overlap_list)) {
  if (ipr_overlap_list[[ipr_pair_name]]$good_overlaps / 
      ipr_overlap_list[[ipr_pair_name]]$all_overlaps >= 
      good_overlap_fraction_cutoff) {
    ipr_i = unlist(stringr::str_split(ipr_pair_name, "_"))[1]
    ipr_j = unlist(stringr::str_split(ipr_pair_name, "_"))[2]
    merge_sets(ipr_i, ipr_j)
  }
}

# Form the table of the found clusters
lead.ipr.table = data.frame(lead.ipr = unlist(parent),
                            ipr.accession = names(parent),
                            stringsAsFactors = F) %>%
  arrange(lead.ipr) %>%
  left_join(clf.ipr.matches.overlap.db_rbp %>%
              dplyr::select(ipr.accession,
                            ipr.description) %>%
              distinct(),
            by = c("ipr.accession"))

row.names(lead.ipr.table) = NULL

unique.lead.iprs = lead.ipr.table %>%
  pull(lead.ipr) %>%
  unique()

ipr.cluster.table = lead.ipr.table %>%
  left_join(data.frame(lead.ipr = unique.lead.iprs,
                       cluster.name = seq(1:length(unique.lead.iprs)),
                       stringsAsFactors = F),
            by = c("lead.ipr")) %>%
  dplyr::select(cluster.name,
                ipr.accession,
                ipr.description) %>%
  group_by(cluster.name) %>%
  mutate(cluster.size = length(ipr.accession)) %>%
  ungroup() %>%
  arrange(desc(cluster.size))

# Write down the table of all clusters
write.table(ipr.cluster.table,
            "output/match_clusters_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

toc()
# ~ 5 sec
```

Name clusters that are present in the plots below, according to the InterPro entries that these clusters contain:

```{r, include=T}
ipr.cluster.table = ipr.cluster.table %>%
  mutate(cluster.name = ifelse(cluster.name == "1", "Disordered region", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "481", "P-loop-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "592", "HTH", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "553", "RRM", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "293", "C2H2-type ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "265", "OB-fold", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "551", "RING/FYVE/PHD ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "51", "Helicase, C-terminal", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "342", "Armadillo-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "317", "DEAD-box-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "52", "WD40 repeat", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "510", "SAM methyltransferase-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "99", "KH domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "32", "MCM domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "580", "C2H2 ZF-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "588", "WD40-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "463", "WD40/YVTN-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "518", "MCM domain-containing", cluster.name))
```

## Find proportions of matched and unmatched CLF peptides from DNA- and RNA-binding proteins

First, find the number and proportion of all unmatched CLF peptides (from DBPs and RBPs) shared between SPACEmap and SPACE:

```{r, include=T}
clf.matched.peptides = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.all.peptides = clf.ipr.matches.base %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.unmatched.peptides = clf.all.peptides %>%
  dplyr::anti_join(clf.matched.peptides,
                   by = c("Uniprot.ID" = "Uniprot.ID",
                          "Sequence" = "Sequence",
                          "N.term.cleavage.window" = "N.term.cleavage.window",
                          "C.term.cleavage.window" = "C.term.cleavage.window"))
```

Hence, we have `r nrow(clf.unmatched.peptides)` unmatched peptides from SPACEmap CLF (`r round(nrow(clf.unmatched.peptides) / nrow(clf.all.peptides) * 100, 1)`% of all peptides from SPACEmap CLF).

## Find frequencies of cluster matches

First, apply our clusterisation to the main table with matched CLА peptides from DNA- and RNA-binding proteins:

```{r, include=T}
clf.ipr.matches.overlap.db_rbp.collated = clf.ipr.matches.overlap.db_rbp %>%
  mutate(ipr.accession = ifelse(ipr.accession == "", "disordered_region", ipr.accession)) %>%
  mutate(ipr.description = ifelse(ipr.description == "", "disordered_region", ipr.description)) %>%
  left_join(ipr.cluster.table %>%
              mutate(ipr.description = ifelse(is.na(ipr.description), "disordered_region", ipr.description)),
            by = c("ipr.accession", "ipr.description")) %>%
  filter(!is.na(cluster.name)) %>%
  mutate(ipr.accession = "") %>%
  mutate(ipr.description = cluster.name)
```

Secondly, generate tables with the frequencies of proteins and peptides with different matches (plot top 10 by frequency).

For the DNA-binding proteins (Fig. 3E; Fig. S3E, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(Category == "DB") %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.collated.db_freq = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(Category == "DB") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.db) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.db_freq,
            "output/clf_db_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.db_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 60), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the RNA-binding proteins (Fig. 3D; Fig. S3D, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.rbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

write.table(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq,
            "output/clf_rbp_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 50), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from DNA-binding proteins (Fig. S3E, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db.peptides = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(Category == "DB") %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(Category == "DB") %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.db.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides,
            "output/clf_db_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.db_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 40), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from RNA-binding proteins (Fig. S3D, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp.peptides = clf.ipr.matches.overlap.db_rbp.collated %>% 
  filter(RBP == "RBP") %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides = clf.ipr.matches.overlap.db_rbp.collated %>%
  filter(RBP == "RBP") %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.rbp.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides,
            "output/clf_rbp_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.db_rbp.collated.rbp_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 30), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the table of generalised entries:

```{r, include=T}
write.table(ipr.cluster.table,
            "output/cluster_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Compare top structural domain types in DNA- and RNA-binding proteins

Take top 5 structural domain types (the general clusters that we found above) in DNA- and RNA-binding proteins and compare their abundance in both groups (Figure S3F):

```{r, include=T}
# Select top 5 matched domain types from DBPs and RBPs, and merge these domain types in one set.
# Let us exclude disordered region matches as here we are interested in domains.
top.matched.domains = unique(c(clf.ipr.matches.overlap.db_rbp.collated.db_freq %>%
                                 arrange(desc(uniprotid.freq)) %>%
                                 head(6) %>% # 5 without IDRs
                                 pull(ipr.description),
                               clf.ipr.matches.overlap.db_rbp.collated.rbp_freq %>%
                                 arrange(desc(uniprotid.freq)) %>%
                                 head(6) %>% # 5 without IDRs
                                 pull(ipr.description)))

freq.in.dbp_rbp = clf.ipr.matches.overlap.db_rbp.collated.db_freq %>%
  filter(ipr.description %in% top.matched.domains) %>%
  dplyr::rename("uniprotid.n.dbp" = "uniprotid.n",
                "uniprotid.freq.dbp" = "uniprotid.freq") %>%
  dplyr::select(-ipr.accession) %>%
  dplyr::full_join(clf.ipr.matches.overlap.db_rbp.collated.rbp_freq %>%
                     filter(ipr.description %in% top.matched.domains) %>%
                     dplyr::rename("uniprotid.n.rbp" = "uniprotid.n",
                                   "uniprotid.freq.rbp" = "uniprotid.freq") %>%
                     dplyr::select(-ipr.accession),
                   by = c("ipr.description" = "ipr.description")) %>%
  tidyr::replace_na(list(uniprotid.n.dbp = 0, 
                         uniprotid.freq.dbp = 0,
                         uniprotid.n.rbp = 0,
                         uniprotid.freq.rbp = 0)) %>%
  arrange(desc(uniprotid.freq.dbp)) %>%
  filter(ipr.description != "Disordered region")

top.matched.domains.ordered = freq.in.dbp_rbp$ipr.description

# Plot the top 5 matched domain types, sorted by decreasing abundance in DBPs
data.frame(domain.type = rep(top.matched.domains.ordered, 2),
           protein.category = c(rep("DBP", length(top.matched.domains.ordered)),
                                rep("RBP", length(top.matched.domains.ordered))),
           protein.freq = c(freq.in.dbp_rbp$uniprotid.freq.dbp,
                            freq.in.dbp_rbp$uniprotid.freq.rbp)) %>%
  mutate(domain.type = factor(domain.type, levels = top.matched.domains.ordered)) %>%
  mutate(protein.freq = protein.freq * 100) %>%
  ggplot(aes(x = domain.type, y = protein.freq)) +
    geom_col(aes(fill = protein.category), position = "dodge2") +
    scale_y_continuous(limits = c(0, 12), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Interestingly, the P-loop-related domains are the top matches, equally frequent in DBPs and RBPs. Although P-loops have been known for a long time as NTP-binding motifs frequently present in various NTP hydrolases ([Vetter and Wittinghofer, 1999](https://www.cambridge.org/core/journals/quarterly-reviews-of-biophysics/article/nucleoside-triphosphatebinding-proteins-different-scaffolds-to-achieve-phosphoryl-transfer/DCF7EEE392136BE87CD82FF3AAD866EC)), recently ([Romero et al., 2018](https://www.pnas.org/content/115/51/E11943)) showed that P-loops can also bind DNA and RNA. Helix-turn-helix (HTH) and C2H2-type ZF clusters are characteristic of DBPs, which corresponds to the well-known DNA-binding role of these domains ([Brennan and Matthews, 1989](https://www.sciencedirect.com/science/article/pii/S0021925818941153); [Wolfe, Nekludova and Pabo, 2000](https://www.annualreviews.org/doi/10.1146/annurev.biophys.29.1.183)). Another top matching cluster, the OB-fold, is also more common in DBPs, but is comparably frequent in RBPs. Indeed, it contains the RNA-binding S1 domain ([Bycroft et al., 1997](https://www.sciencedirect.com/science/article/pii/S0092867400818449)), the cold shock domain capable of both DNA- and RNA-binding ([Lindquist and Mertens, 2018](https://biosignaling.biomedcentral.com/articles/10.1186/s12964-018-0274-6)), and ribosomal proteins that may contact rRNA. Other top clusters match more frequently in RBPs. Namely, the RNA recognition motif (RRM) is almost two times more frequent in RBPs than in DBPs, in accord with its definition. It can also bind single-strand DNA ([Ding et al., 1999](http://genesdev.cshlp.org/content/13/9/1102.long)), which may explain its still considerable frequency in DBPs. Next, the domains from the "Helicase, C-terminal" cluster have not as yet been shown to bind DNA; however, as part of DNA and RNA helicases, they could contact both types of nucleic acid molecules. The other two clusters more frequent in RBPs are the Armadillo-related and the  DEAD-box-related ones. In the Armadillo-related cluster, both the Pumillo homology domain and the MIF4G domains are known RNA binders ([Wang et al., 2002](https://www.sciencedirect.com/science/article/pii/S0092867402008735); [Marintchev and Wagner, 2005](https://pubs.acs.org/doi/10.1021/bi051271v)). Some other entries in this cluster represent domains from translation factors or nucleolus-localised proteins; hence, these domains, not as yet shown to be DNA or RNA binders, could indeed bind DNA or RNA molecules. Finally, entries from the DEAD-box-related cluster also have not been shown to bind RNA, although they belong to RNA and DNA helicases, and one of the entries (IPR014001) describes a DNA-binding domain. Overall, SPACEmap detects both known and possible novel DNA- and RNA-binding domains.

## Study unmatched CLF peptides from SPACEmap

Unmatched CLF peptides from SPACEmap may have motifs representing as yet undiscovered domains. Let us scan the unmatched peptide sequences with MeMe. For this, we need to prepare the sequences first: (a) merge N- and C-terminal flanks with the peptide sequences by overlaps (so that if a motif goes into flanks, it would be captured); (b) merge the combined sequences from the same protein by overlaps (we want to avoid a situation when a motif is deemed significant just because it is constructed from overlapping peptide sequences); (c) filter out sequences that are shorter than 8 amino acids (MEME's threshold for sequence length). Let us prepare the sequences:

```{r, include=T}
# Merge two strings by an overlap or concatenate them if there is no overlap
str_merge = function(str1, str2) {
  if ((str1 == "") & (str2 == "")) {
    return("")
  }
  if (str1 == "") {
    return(str2)
  }
  if (str2 == "") {
    return(str1)
  }
  if (stringr::str_detect(str1, fixed(str2))) {
    return(str1)
  }
  if (stringr::str_detect(str2, fixed(str1))) {
    return(str2)
  }
  str1_length = nchar(str1)
  str2_length = nchar(str2)
  max_prefix_coordinate = 0
  for (i in seq(0, min(str1_length, str2_length) - 1)) {
    if (substr(str1, str1_length - i, str1_length) == substr(str2, 1, i + 1)) {
      max_prefix_coordinate = i + 1
    }
  }
  if (max_prefix_coordinate == 0) {
    return(paste0(str1, str2))
  }
  return(paste0(str1, substr(str2, max_prefix_coordinate + 1, str2_length)))
}

# Assemble sequences by overlaps
calc_str_merge = function(str1, str2) {
  if (stringr::str_detect(str1, fixed(str2))) {
    return(list("length" = nchar(str2),
                "merge" = str1))
  }
  if (stringr::str_detect(str2, fixed(str1))) {
    return(list("length" = nchar(str1),
                "merge" = str2))
  }
  str1_length = nchar(str1)
  str2_length = nchar(str2)
  max_prefix_coordinate = 0
  for (i in seq(0, min(str1_length, str2_length) - 1)) {
    if (substr(str1, str1_length - i, str1_length) == substr(str2, 1, i + 1)) {
      max_prefix_coordinate = i + 1
    }
  }
  return(list("length" = max_prefix_coordinate,
              "merge" = paste0(str1, substr(str2, max_prefix_coordinate + 1, str2_length))))
}

merge_sequences = function(sequence.lead, sequence.lag) {
  merge.list.lead.lag = calc_str_merge(sequence.lead, sequence.lag)
  merge.list.lag.lead = calc_str_merge(sequence.lag, sequence.lead)
  if (merge.list.lead.lag[["length"]] >= merge.list.lag.lead[["length"]]) {
    return(merge.list.lead.lag)
  }
  return(merge.list.lag.lead)
}

assemble_by_overlaps = function(uniprotid,
                                input.sequences) {
  if (length(input.sequences) == 1) {
    return(data.frame(Uniprot.ID = uniprotid, 
                      contigs = input.sequences[1], 
                      status = "original",
                      stringsAsFactors = F))
  }
  overlap.size.cutoff = 5
  sequences.to.assemble = input.sequences
  contigs.to.report = c()
  status.list = list()
  for (input.sequence in input.sequences) {
    status.list[[input.sequence]] = "original"
  }
  contig.status.list = list()
  while (length(sequences.to.assemble) > 1) {
    sequence.lead = sequences.to.assemble[1]
    max.overlap.length = 0
    max.overlap.index = 0
    max.overlap.sequence.lag = ""
    max.overlap.merge = ""
    for (lag.i in 2:(length(sequences.to.assemble))) {
      sequence.lag = sequences.to.assemble[lag.i]
      merge.list = merge_sequences(sequence.lead, sequence.lag)
      overlap.length = merge.list[["length"]]
      overlap.merge = merge.list[["merge"]]
      if (overlap.length > max.overlap.length) {
        max.overlap.length = overlap.length
        max.overlap.index = lag.i
        max.overlap.sequence.lag = sequence.lag
        max.overlap.merge = overlap.merge
      }
    }
    if (max.overlap.length >= overlap.size.cutoff) {
      sequences.to.assemble = sequences.to.assemble[-max.overlap.index]
      status.list[[max.overlap.sequence.lag]] = NULL
      sequences.to.assemble = sequences.to.assemble[-1]
      status.list[[sequence.lead]] = NULL
      sequences.to.assemble[length(sequences.to.assemble) + 1] = max.overlap.merge
      status.list[[max.overlap.merge]] = "merged"
    } else {
      sequences.to.assemble = sequences.to.assemble[-1]
      contigs.to.report[length(contigs.to.report) + 1] = sequence.lead
      contig.status.list[length(contig.status.list) + 1] = status.list[[sequence.lead]]
      status.list[[sequence.lead]] = NULL
    }
  }
  contigs.to.report[length(contigs.to.report) + 1] = sequences.to.assemble[1]
  contig.status.list[length(contig.status.list) + 1] = status.list[1]
  
  return(data.frame(Uniprot.ID = rep(uniprotid, length(sequences.to.assemble)), 
                    contigs = contigs.to.report, 
                    status = unlist(contig.status.list), 
                    stringsAsFactors = F))
}

clf.all.matched.peptides = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.all.peptides = clf.ipr.matches.base %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.all.unmatched.peptides = clf.all.peptides %>%
  dplyr::anti_join(clf.all.matched.peptides,
                   by = c("Uniprot.ID" = "Uniprot.ID",
                          "Sequence" = "Sequence",
                          "N.term.cleavage.window" = "N.term.cleavage.window",
                          "C.term.cleavage.window" = "C.term.cleavage.window"))

clf.all.unmatched.peptides.merged = clf.all.unmatched.peptides %>%
    group_by(Uniprot.ID,
             Sequence,
             N.term.cleavage.window,
             C.term.cleavage.window) %>%
    do(mutate(., peptide.sequence = str_merge(
                                      str_merge(
                                        stringr::str_replace_all(.$N.term.cleavage.window, "_", ""),
                                        stringr::str_replace_all(.$Sequence, "_", "")),
                                      stringr::str_replace_all(.$C.term.cleavage.window, "_", "")))) %>%
  ungroup()

tic("Assemble peptide sequences")
clf.all.unmatched.peptides.merged.assembled = dplyr::bind_rows(purrr::map(clf.all.unmatched.peptides.merged %>%
                                                                            pull(Uniprot.ID) %>%
                                                                            unique(),
                                                                          function(uniprotid) {
                                                                            assemble_by_overlaps(uniprotid,
                                                                                                 clf.all.unmatched.peptides.merged %>%
                                                                                                   filter(Uniprot.ID == uniprotid) %>%
                                                                                                   pull(peptide.sequence))
                                                                          }))
toc()
# ~ 0.7 sec

# Filter out short sequences and form sequence headers for FASTA
clf.all.unmatched.peptides.merged.assembled.final = clf.all.unmatched.peptides.merged.assembled %>%
  filter(nchar(contigs) > 8) %>%
  group_by(Uniprot.ID) %>%
  mutate(fasta.header = paste(Uniprot.ID, as.character(row_number()), sep = "_")) %>%
  ungroup()

# Write down the final table
write.table(clf.all.unmatched.peptides.merged.assembled.final,
            "output/final_assembled_peptide_sequences_clf.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Write down FASTA with the final sequences
write.fasta(as.list(clf.all.unmatched.peptides.merged.assembled.final %>%
                      pull(contigs)),
            as.list(clf.all.unmatched.peptides.merged.assembled.final %>%
                      pull(fasta.header)),
            "output/final_assembled_peptide_sequences_clf.fa")
```

We searched motifs _de novo_ in the sequences from the FASTA file using MeMe Suite v5.3.3 with default options, but did not find any significant motifs at the level of e-value < 0.05 (see output/meme_reports).

## Calculate peptide abundance in DBDs vs CLF/RF intensity ratio

Upload the table of DBDs (was obtained for human transcription factors):

```{r, include=T}
dbd.table = read.delim("input/dbd_table_manually_annotated.tsv")
```

Generate the overall table of SPACEmap peptides from matched proteins, and also captured by SPACE:

```{r, include=T}
all.ipr.matches.base = bind_rows(clf.ipr.matches.base %>%
                                   dplyr::select(-Category, -RBP) %>%
                                   mutate(fraction.type = "CLF"),
                                 rf.ipr.matches.base %>%
                                   mutate(fraction.type = "RF"))
```

Join the overall table of peptides with the table of classical DBDs from human TFs:

```{r, include=T}
all.ipr.matches.base.dbd = all.ipr.matches.base %>%
  left_join(dbd.table,
            by = c("ipr.accession" = "ipr_accession",
                   "ipr.description" = "ipr_description"))
```

Mark each peptide as matched or unmatched:

```{r, include=T}
match.vicinity = 10
all.ipr.matches.base.dbd.marked = all.ipr.matches.base.dbd %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  mutate(category = ifelse(is.na(category), "", category)) %>%
  mutate(match.dbd.overlap = (match.peptide.overlap & category == "DBD")) %>%
  group_by(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  mutate(match.dbd.overlap = sum(match.dbd.overlap)) %>%
  ungroup() %>%
  mutate(match.dbd.overlap = ifelse(match.dbd.overlap >= 1, 1, 0)) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window,
                match.peptide.overlap, match.dbd.overlap, logFC,
                represents_family, fraction.type) %>%
  distinct() %>%
  filter(match.peptide.overlap)
```

Calculate ratios of CLF and RF peptides that overlap with the classical DBDs:

```{r, include=T}
cat("CLF:", (all.ipr.matches.base.dbd.marked %>%
      filter(fraction.type == "CLF") %>%
      filter(match.dbd.overlap == 1) %>%
      nrow()) / 
      (all.ipr.matches.base.dbd.marked %>%
         filter(fraction.type == "CLF") %>%
         nrow()), "\n")
cat("RF:", (all.ipr.matches.base.dbd.marked %>%
      filter(fraction.type == "RF") %>%
      filter(match.dbd.overlap == 1) %>%
      nrow()) / 
      (all.ipr.matches.base.dbd.marked %>%
         filter(fraction.type == "RF") %>%
         nrow()), "\n")
```

## Stratify all CLF peptides by matches

Count CLF peptides (from DNA- and RNA-binding proteins) that match domains, IDRs, and those who do not match any feature:

```{r, include=T}
# First, we ran `classify_domains.py` to obtain a table of all InterPro v82 entries classified into "Putative DBD" (if the word "DNA" is present in the entry) and "Other" (if the word "DNA" is not present in the entry). In this way, we obtained the `output/interpro82_domain_binary_classification.tsv` table.
ipr.draft.classes = read.delim("output/interpro82_domain_binary_classification.tsv")

clf.peptides.coord = annot.table %>%
  left_join(peptide.table, by = "Uniprot.ID") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window,
                Start.position,
                End.position,
                Category,
                RBP) %>%
  filter(!is.na(Sequence)) %>%
  filter(Category == "DB" | RBP == "RBP") %>%
  distinct()

match.vicinity = 10 # amino acids

clf.peptides.matches = clf.peptides.coord %>%
  left_join(clf.ipr.matches,
            by = c("Uniprot.ID" = "uniprot.id")) %>%
  left_join(ipr.draft.classes,
            by = c("ipr.accession" = "ipr_accession")) %>%
  dplyr::rename("IPR.category" = "category") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window, 
                Start.position, 
                End.position,
                Category,
                RBP,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description,
                IPR.category) %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  mutate(matched.feature = ifelse(!match.peptide.overlap, 
                                  "None",
                                  ifelse(ipr.accession == "",
                                         "IDR",
                                         ifelse(IPR.category == "DNA-related",
                                                "Domain, DNA-related",
                                                "Domain, Other")))) %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  do(mutate(., matched = ifelse(("Domain, DNA-related" %in% .$matched.feature | "Domain, Other" %in% .$matched.feature) & 
                                 "IDR" %in% .$matched.feature,
                                "Domain+IDR",
                                ifelse("Domain, DNA-related" %in% .$matched.feature & "Domain, Other" %in% .$matched.feature,
                                       "Domain, DNA-related + Other",
                                       ifelse("Domain, DNA-related" %in% .$matched.feature,
                                              "Domain, DNA-related",
                                              ifelse("Domain, Other" %in% .$matched.feature,
                                                     "Domain, Other",
                                                     ifelse("IDR" %in% .$matched.feature,
                                                            "IDR",
                                                            "None"))))))) %>%
  ungroup()

# Final match table
write.table(clf.peptides.matches,
            file = "output/dbp_rbp_clf_peptide_matches_stratified.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

```

Compare the frequencies of Domain-, IDR- and (Domain+IDR)-matching and unmatched peptides in DBPs and RBPs:

```{r, include=T}
clf.peptides.matches.stratified = clf.peptides.matches

peptides.matched.domain_dna_related.n.db = clf.peptides.matches.stratified %>% 
  filter(Category == "DB") %>%
  filter(matched == "Domain, DNA-related") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_other.n.db = clf.peptides.matches.stratified %>% 
  filter(Category == "DB") %>%
  filter(matched == "Domain, Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_both.n.db = clf.peptides.matches.stratified %>% 
  filter(Category == "DB") %>%
  filter(matched == "Domain, DNA-related + Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_dna_related.n.rbp = clf.peptides.matches.stratified %>% 
  filter(RBP == "RBP") %>%
  filter(matched == "Domain, DNA-related") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_other.n.rbp = clf.peptides.matches.stratified %>% 
  filter(RBP == "RBP") %>%
  filter(matched == "Domain, Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_both.n.rbp = clf.peptides.matches.stratified %>% 
  filter(RBP == "RBP") %>%
  filter(matched == "Domain, DNA-related + Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.idr.n.db = clf.peptides.matches.stratified %>% 
  filter(Category == "DB") %>%
  filter(matched == "IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.idr.n.rbp = clf.peptides.matches.stratified %>% 
  filter(RBP == "RBP") %>%
  filter(matched == "IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_idr.n.db = clf.peptides.matches.stratified %>% 
  filter(Category == "DB") %>%
  filter(matched == "Domain+IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_idr.n.rbp = clf.peptides.matches.stratified %>% 
  filter(RBP == "RBP") %>%
  filter(matched == "Domain+IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.none.n.db = clf.peptides.matches.stratified %>% 
  filter(Category == "DB") %>%
  filter(matched == "None") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.none.n.rbp = clf.peptides.matches.stratified %>% 
  filter(RBP == "RBP") %>%
  filter(matched == "None") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.all.n.db = clf.peptides.matches.stratified %>% 
  filter(Category == "DB") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.all.n.rbp = clf.peptides.matches.stratified %>% 
  filter(RBP == "RBP") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

cat("DBPs:\n")
cat("Domain, DNA-related:", 
    peptides.matched.domain_dna_related.n.db, 
    paste0("(", round(peptides.matched.domain_dna_related.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("Domain, Other      :", 
    peptides.matched.domain_other.n.db, 
    paste0("(", round(peptides.matched.domain_other.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("Domain, both       :", 
    peptides.matched.domain_both.n.db, 
    paste0("(", round(peptides.matched.domain_both.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("Domain+IDR         :", 
    peptides.matched.domain_idr.n.db, 
    paste0("(", round(peptides.matched.domain_idr.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("IDR                :", 
    peptides.matched.idr.n.db, 
    paste0("(", round(peptides.matched.idr.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("None               :", 
    peptides.matched.none.n.db, 
    paste0("(", round(peptides.matched.none.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))

cat("RBPs:\n")
cat("Domain, DNA-related:", 
    peptides.matched.domain_dna_related.n.rbp, 
    paste0("(", round(peptides.matched.domain_dna_related.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("Domain, Other      :", 
    peptides.matched.domain_other.n.rbp, 
    paste0("(", round(peptides.matched.domain_other.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("Domain, both       :", 
    peptides.matched.domain_both.n.rbp, 
    paste0("(", round(peptides.matched.domain_both.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("Domain+IDR         :", 
    peptides.matched.domain_idr.n.rbp, 
    paste0("(", round(peptides.matched.domain_idr.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("IDR                :", 
    peptides.matched.idr.n.rbp, 
    paste0("(", round(peptides.matched.idr.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("None               :", 
    peptides.matched.none.n.rbp, 
    paste0("(", round(peptides.matched.none.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))

data.frame(category = rep(c("Domain, DNA-related", "Domain, Other", "Domain, both", "Domain+IDR", "IDR", "None"), 2),
           feature = c(rep("DBPs", 6), rep("RBPs", 6)),
           fraction = c(peptides.matched.domain_dna_related.n.db  / peptides.matched.all.n.db,
                        peptides.matched.domain_other.n.db        / peptides.matched.all.n.db,
                        peptides.matched.domain_both.n.db         / peptides.matched.all.n.db,
                        peptides.matched.domain_idr.n.db          / peptides.matched.all.n.db,
                        peptides.matched.idr.n.db                 / peptides.matched.all.n.db,
                        peptides.matched.none.n.db                / peptides.matched.all.n.db,
                        peptides.matched.domain_dna_related.n.rbp / peptides.matched.all.n.rbp,
                        peptides.matched.domain_other.n.rbp       / peptides.matched.all.n.rbp,
                        peptides.matched.domain_both.n.rbp        / peptides.matched.all.n.rbp,
                        peptides.matched.domain_idr.n.rbp         / peptides.matched.all.n.rbp,
                        peptides.matched.idr.n.rbp                / peptides.matched.all.n.rbp,
                        peptides.matched.none.n.rbp               / peptides.matched.all.n.rbp)) %>%
  mutate(category = factor(category, levels = c("Domain, DNA-related", 
                                                "Domain, Other", 
                                                "Domain, both",
                                                "Domain+IDR", 
                                                "IDR", 
                                                "None"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

Visually inspect simultaneous matches of DNA-related and Other domains:

```{r, include=T}
clf.peptides.matches.stratified %>%
  filter(matched == "Domain, DNA-related + Other") %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(-Category, -RBP, -match.peptide.overlap, -matched.feature)
```

There are a lot of peptides that match a DNA-related and an Other domain at the same time. From the visual inspection of the `clf.peptides.matches.stratified` table, it is clear that these peptides are matched by domains of different generality in the InterPro hierarchy or by a domain and a superfamily one of which is qualified as DNA-related and the other - as Other. Hence, stratification of domains into DNA-related and Other does not make much sense, and we need to stick to the general "Domain" group and manually curate all domains to gain insight into their relevance to chromatin.

Plot the same frequencies with all domains in one group:

```{r, include = T}
data.frame(category = rep(c("Domain", "Domain+IDR", "IDR", "None"), 2),
           feature = c(rep("DBPs", 4), rep("RBPs", 4)),
           fraction = c((peptides.matched.domain_dna_related.n.db + 
                           peptides.matched.domain_other.n.db + 
                           peptides.matched.domain_both.n.db) / 
                          peptides.matched.all.n.db,
                        peptides.matched.domain_idr.n.db          / peptides.matched.all.n.db,
                        peptides.matched.idr.n.db                 / peptides.matched.all.n.db,
                        peptides.matched.none.n.db                / peptides.matched.all.n.db,
                        (peptides.matched.domain_dna_related.n.rbp + 
                           peptides.matched.domain_other.n.rbp + 
                           peptides.matched.domain_both.n.rbp) / 
                          peptides.matched.all.n.rbp,
                        peptides.matched.domain_idr.n.rbp         / peptides.matched.all.n.rbp,
                        peptides.matched.idr.n.rbp                / peptides.matched.all.n.rbp,
                        peptides.matched.none.n.rbp               / peptides.matched.all.n.rbp)) %>%
  mutate(category = factor(category, levels = c("Domain",
                                                "Domain+IDR", 
                                                "IDR", 
                                                "None"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

Generate a base table of peptide matches, without domain stratification:

```{r, include=T}
clf.peptides.matches.unstratified = clf.peptides.matches %>%
  mutate(matched = ifelse(stringr::str_detect(matched, "Domain,"),
                          "Domain",
                          matched))

# Final match table, base
write.table(clf.peptides.matches.unstratified,
            file = "output/dbp_rbp_clf_peptide_matches_unstratified.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Prepare the draft classification table of InterPro entries matched to CLF peptides from DNA- and RNA-binding proteins:

```{r, include=T}
ipr.draft.classes.clf = clf.peptides.matches %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(ipr.accession,
                ipr.description) %>%
  distinct() %>%
  left_join(ipr.draft.classes,
            by = c("ipr.accession" = "ipr_accession")) %>%
  filter(!is.na(category))

write.table(ipr.draft.classes.clf,
            "output/ipr_draft_classes_clf.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Check the proportions of "DNA-related" and "Other" InterPro entries among all matched entries:

```{r, include=T}
ipr.draft.classes.clf.dna_related.n = ipr.draft.classes.clf %>%
  filter(category == "DNA-related") %>%
  pull(ipr.accession) %>%
  unique() %>%
  length()

ipr.draft.classes.clf.all.n = ipr.draft.classes.clf %>%
  pull(ipr.accession) %>%
  unique() %>%
  length()

cat("Number of DNA-related entries:", 
    ipr.draft.classes.clf.dna_related.n, 
    paste0("(", round(ipr.draft.classes.clf.dna_related.n / ipr.draft.classes.clf.all.n * 100, 2), "%)\n"))

data.frame(category = c("DNA-related", "Other"),
           feature = rep("Matched InterPro entries", 2),
           fraction = c(ipr.draft.classes.clf.dna_related.n / ipr.draft.classes.clf.all.n,
                        1 - ipr.draft.classes.clf.dna_related.n / ipr.draft.classes.clf.all.n)) %>%
  mutate(category = factor(category, levels =  c("DNA-related", "Other"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

## Check CLF peptides in known DBDs

Select CLF proteins (DBPs and RBPs only) with known DBDs:

```{r, include=T}
clf.ipr.matches.base.dbd_matches = clf.ipr.matches.base %>%
  filter(Category == "DB" | RBP == "RBP") %>%
  filter(ipr.accession %in% dbd.table$ipr_accession) %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  group_by(Uniprot.ID) %>%
  do(mutate(., dbd.matched = Reduce(function(x, y) x | y, .$match.peptide.overlap))) %>%
  ungroup()

matched.proteins = clf.ipr.matches.base.dbd_matches %>%
  filter(dbd.matched) %>%
  pull(Uniprot.ID) %>%
  unique()

unmatched.proteins = clf.ipr.matches.base.dbd_matches %>%
  filter(!dbd.matched) %>%
  pull(Uniprot.ID) %>%
  unique()

matched.proteins.n = length(matched.proteins)

unmatched.proteins.n = length(unmatched.proteins)

all.proteins = clf.ipr.matches.base.dbd_matches %>%
  pull(Uniprot.ID) %>%
  unique()

all.proteins.n = length(all.proteins)

data.frame(category = c("Matched DBD", "Unmatched DBD"),
           feature = c("DBPs and RBPs with DBDs"),
           fraction = c(matched.proteins.n / all.proteins.n,
                        unmatched.proteins.n / all.proteins.n)) %>%
  mutate(category = factor(category, levels = c("Matched DBD", "Unmatched DBD"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

Check any matches present in DBPs and RBPs where known DBDs are not matched by CLF peptides:

```{r, include=T}
unmatched.proteins.other_matches = clf.ipr.matches.base %>%
  filter(Category == "DB" | RBP == "RBP") %>%
  filter(Uniprot.ID %in% unmatched.proteins) %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  group_by(Uniprot.ID) %>%
  do(mutate(., site.matched = Reduce(function(x, y) x | y, .$match.peptide.overlap))) %>%
  ungroup()

unmatched.proteins.other_matches %>%
  filter(site.matched)

unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap)

unmatched.proteins.other_matches %>%
  filter(!site.matched)
```

Check how many proteins are matched by each of the non-DBD entries:

```{r, include=T}
unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, ipr.accession, ipr.description) %>%
  distinct() %>%
  group_by(ipr.accession, ipr.description) %>%
  do(mutate(., n = nrow(.))) %>%
  ungroup() %>%
  dplyr::select(-Uniprot.ID) %>%
  distinct() %>%
  arrange(desc(n))
```

Check if matched domains not regarded as known DBDs are still potential DBDs:

```{r, include=T}
unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(ipr.accession, ipr.description) %>%
  distinct()
```



