---
title: "Analysis of the crosslinked and released fractions of peptides from SPACEmap"
author: "Sviatoslav Sidorov"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
   html_document:
     code_folding: hide
     collapsed: no
     fig_align: center
     fig_caption: yes
     highlight: haddock
     keep_md: yes
     number_sections: yes
     smooth_scroll: no
     toc: yes
     toc_depth: 3
     toc_float: yes
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/rstudio") # Please change to yours
#opts_knit$set(root.dir = "/Volumes/lab-luscomben/home/users/sidoros/projects/spacemap-peptide-analysis") 
knitr::opts_chunk$set(echo = TRUE)
stringsAsFactors = F

library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(tibble)
library(ggplot2)
library(ggrepel)
dyn.load("/home/rstudio/libs/libicudata.so.67")
dyn.load("/home/rstudio/libs/libicuuc.so.67")
dyn.load("/home/rstudio/libs/libxml2.so.2")
dyn.load("/home/rstudio/libs/libiconv.so.2")
library(kableExtra)
library(scales)
library(tictoc)
library(seqinr)
```

## Filter released peptides according to the new table of SPACE proteins

```{r, include=T}
# space.new = read.delim("input/SPACE.txt")
# 
# # Filter the released peptide table
# released.old = read.delim("input/prev/Released_fraction.txt_overlapped_with_SPACE.tsv")
# 
# released.new = released.old %>%
#   filter(Uniprot.ID %in% space.new$Uniprot.ID)
# 
# write.table(released.new,
#             "input/Released_fraction.txt_overlapped_with_SPACE.tsv",
#             quote = F,
#             sep = "\t",
#             row.names = F)
# 
# # Filter scan results for released proteins
# released.scan.table.old = read.delim("input/prev/Released_fraction.txt_overlapped_with_SPACE.fa.tsv",
#                                      header = F)
# 
# released.scan.table.new = released.scan.table.old %>%
#   dplyr::rename("seq.id" = "V1") %>%
#   group_by(seq.id) %>%
#   mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
#   ungroup() %>%
#   filter(uniprot.id %in% space.new$Uniprot.ID) %>%
#   dplyr::select(-uniprot.id) %>%
#   mutate(V10 = ifelse(V10, "T", "F"))
# 
# write.table(released.scan.table.new,
#             "input/Released_fraction.txt_overlapped_with_SPACE.fa.tsv",
#             quote = F,
#             sep = "\t",
#             row.names = F,
#             col.names = F)
#
# # Filter FASTA with released protein sequences
# released.fasta.old = read.delim("input/prev/Released_fraction.txt_overlapped_with_SPACE.fa",
#                                 header = F)
# uniprot.id.current = ""
# sequence.current = ""
# released.fasta.table = data.frame(fasta.header = character(),
#                                   fasta.sequence = character())
# for (i in 1:(nrow(released.fasta.old))) {
#   fasta.row = released.fasta.old[i, 1]
#   if (stringr::str_starts(fasta.row, ">")) {
#     uniprot.id.next = fasta.row
#     if (uniprot.id.current != "") {
#       released.fasta.table = released.fasta.table %>% 
#         bind_rows(data.frame(fasta.header = uniprot.id.current,
#                              fasta.sequence = sequence.current))
#       sequence.current = ""
#     }
#     uniprot.id.current = uniprot.id.next
#   } else {
#     sequence.current = paste0(sequence.current, fasta.row)
#   }
# }
# released.fasta.table = released.fasta.table %>%
#   bind_rows(data.frame(fasta.header = uniprot.id.current,
#                        fasta.sequence = sequence.current))
# 
# released.fasta.table.new = released.fasta.table %>%
#   group_by(fasta.header) %>%
#   filter(unlist(stringr::str_split(fasta.header, fixed("|")))[2] %in% space.new$Uniprot.ID) %>%
#   ungroup()
# 
# released.fasta.table.fa = data.frame(x = character())
# for (i in 1:(nrow(released.fasta.table.new))) {
#   released.fasta.table.fa = released.fasta.table.fa %>%
#     bind_rows(data.frame(x = c(as.character(released.fasta.table.new[i, 1]),
#                                as.character(released.fasta.table.new[i, 2]))))
# }
# 
# write.table(released.fasta.table.fa,
#             "input/Released_fraction.txt_overlapped_with_SPACE.fa",
#             quote = F,
#             sep = "\t",
#             row.names = F,
#             col.names = F)
```

## Obtain the table of InterPro matches in peptides from crosslinked fraction

Using InterProScan, we scanned all proteins containing at least one peptide from the crosslinked fraction (see `scan_clf.sh`).

Upload and filter the scan results; calculate integrated coordinates of the matches:

```{r, include=T}
signature.overlap.fraction = 0.7

find_consensus_matches = function(start, stop) {
  df = data.frame(int.start.cons = start,
                  int.stop.cons = stop,
                  stringsAsFactors = F)
  
  i = 1
  while (i <= nrow(df)) {
    start.i = df[i, ]$int.start.cons
    stop.i = df[i, ]$int.stop.cons
    j = i + 1
    while (j <= nrow(df)) {
      start.j = df[j, ]$int.start.cons
      stop.j = df[j, ]$int.stop.cons
      i.length = stop.i - start.i + 1
      j.length = stop.j - start.j + 1
      i.j.overlap.size = min(stop.i, stop.j) - max(start.i, start.j) + 1
      if ((i.j.overlap.size > signature.overlap.fraction * i.length) | 
          (i.j.overlap.size > signature.overlap.fraction * j.length)) {
        new.start.cons = min(start.i, start.j)
        new.stop.cons = max(stop.i, stop.j)
        old.start.cons.i = df[i, ]$int.start.cons
        old.stop.cons.i = df[i, ]$int.stop.cons
        df[i, ]$int.start.cons = new.start.cons
        df[i, ]$int.stop.cons = new.stop.cons
        start.i = new.start.cons
        stop.i = new.stop.cons
        df[j, ]$int.start.cons = new.start.cons
        df[j, ]$int.stop.cons = new.stop.cons
      }
      j = j + 1
    }
    i = i + 1
  }
  
  return(df %>% 
           dplyr::select(int.start.cons,
                         int.stop.cons))
    
}

# Read the InterProScan results
clf.ipr.matches = read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and 
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r clf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r clf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Define functions to plot InterPro scan results for a protein by UniProt ID:

```{r, include=T}
generate_protein_df = function(UniProtId) {
  return(read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                    header = F,
                    colClasses = c("character",
                                   "character",
                                   "numeric",
                                   "character",
                                   "character",
                                   "character",
                                   "numeric",
                                   "numeric",
                                   "character",
                                   "character",
                                   "character",
                                   "character",
                                   "character"),
                    col.names = c("seq.id",
                                  "md5",
                                  "seq.length",
                                  "db",
                                  "signature.accession",
                                  "signature.description",
                                  "start",
                                  "stop",
                                  "score",
                                  "status",
                                  "date",
                                  "ipr.accession",
                                  "ipr.description")) %>%
         filter(status == "T") %>%
         # Select domains that are integrated into InterPro (ipr.accession != "") and 
         # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
         # Parse the protein sequence headers and take the Uniprot IDs
         group_by(seq.id) %>%
         mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
         ungroup() %>%
         filter(uniprot.id == UniProtId))
}

preprocess_protein_df = function(protein.df) {
  c = 10 # vertical space between InterPro entries
  h = 5  # height of a match rectangle
  d = 5  # vertical space between rectangles
  
  protein.df = protein.df %>%
    dplyr::select(seq.length,
                  signature.accession,
                  uniprot.id,
                  start,
                  stop,
                  ipr.accession) %>%
    dplyr::rename(length = seq.length,
                           db.accession = signature.accession) %>%
    arrange(desc(start), desc(stop))
  
  ipr.numbers = unique(protein.df$ipr.accession)
  ipr.numbers = ipr.numbers[ipr.numbers != ""]
  ipr.numbers = c(ipr.numbers, "")
  names(ipr.numbers) = as.character(1:(length(ipr.numbers)))
  
  protein.df = protein.df %>%
    rowwise() %>%
    mutate(ipr.n = as.numeric(names(ipr.numbers[ipr.numbers == ipr.accession]))) %>%
    arrange(ipr.n) %>%
    rownames_to_column(var = "row.n") %>%
    mutate(row.n = as.numeric(row.n)) %>%
    mutate(ymin = ipr.n * c + (row.n - 1) * (h + d)) %>%
    mutate(ymax = ymin + h)
  
  return(protein.df)
}

generate_ipr_df = function(protein.df) {
  ipr.label.shift.x = -10
  ipr.label.shift.y = 5
  return(protein.df %>%
         dplyr::select(ipr.accession,
                       start,
                       stop,
                       ymax) %>%
         group_by(ipr.accession) %>%
         do(mutate(., ipr.x = (min(.$start) + max(.$stop)) / 2 + ipr.label.shift.x)) %>%
         do(mutate(., ipr.y = max(.$ymax) + ipr.label.shift.y)) %>%
         ungroup() %>%
         dplyr::select(ipr.accession,
                       ipr.x,
                       ipr.y) %>%
         distinct())
}

draw_matches = function(uniprot.id) {
  signature.label.shift.x = 30
  label.font.size = 3
  x.axis.extension = 50
  
  protein.df = generate_protein_df(uniprot.id)
  
  protein.df = preprocess_protein_df(protein.df)
  
  ipr.df = generate_ipr_df(protein.df)
  
  ggplot(protein.df) +
    # Matches
    geom_rect(mapping = aes(xmin = start,
                            xmax = stop,
                            ymin = ymin,
                            ymax = ymax,
                            fill = db.accession)) +
    # Signature IDs
    geom_text(aes(x = stop + signature.label.shift.x,
                  y = (ymin + ymax) / 2,
                  label = db.accession),
              size = label.font.size) +
    # InterPro IDs
    geom_text(data = ipr.df,
              aes(x = ipr.x,
                  y = ipr.y,
                  label = ipr.accession),
              size = label.font.size) +
    # Protein C-terminal mark
    geom_vline(xintercept = unlist(protein.df[1, "length"])) + 
    # Ruler
    scale_x_continuous(n.breaks = 7, 
                       limits = c(0, unlist(protein.df[1, "length"]) + x.axis.extension)) +
    # Formatting
    theme_classic() + 
    theme(axis.line.y = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.x = element_blank(),
          legend.position="none")
}
```

Print an example of scanning results from an InterPro:

```{r}
draw_matches("A2A4P0")
```

## Find overlaps of matches with peptides

Join the InterPro match table with the peptide and protein annotation tables (take the intersection with the annotation table, as the annotation table is the reference, i. e. peptides from SPACE):

```{r, include=T}
# Read in the table of proteins and peptides from SPACEmap CLF
peptide.table = read.delim("input/Crosslinked_fraction_CLF.tsv",
                           header = T,
                           sep = "\t",
                           stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names)

# Read the table of chromatin-binding proteins (CBPs) identified by SPACE
annot.table.cbp = read.delim("input/SPACE_chromatin-binders.txt", 
                             header = T,
                             sep = "\t",
                             stringsAsFactors = F)

# Read the table of RNA-binding proteins (RBPs) identified by SPACE
annot.table.rbp = read.delim("input/SPACE_RBP_All.txt", 
                             header = T,
                             sep = "\t",
                             stringsAsFactors = F)

# Read the table of proteins and peptides identified by SPACE
annot.table = read.delim("input/SPACE.txt", 
                         header = T,
                         sep = "\t",
                         stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID) %>% 
  left_join(annot.table.cbp %>%
              dplyr::select(Uniprot.ID,
                            Gene.names),
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  dplyr::rename("is.cbp" = "Gene.names") %>%
  mutate(is.cbp = !is.na(is.cbp)) %>%
  left_join(annot.table.rbp %>%
              dplyr::select(Uniprot.ID,
                            Gene.names),
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  dplyr::rename("is.rbp" = "Gene.names") %>%
  mutate(is.rbp = !is.na(is.rbp))

clf.ipr.matches.base = annot.table %>%
  left_join(clf.ipr.matches,
            by = c("Uniprot.ID" = "uniprot.id")) %>%
  left_join(peptide.table,
            by = c("Uniprot.ID" = "Uniprot.ID")) %>%
  filter(!is.na(ipr.accession))
```

Now we have `r clf.ipr.matches.base %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.base %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered region matches in `r clf.ipr.matches.base %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins. The total number of peptides is `r clf.ipr.matches.base %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()`.

The number of CBPs is `r clf.ipr.matches.base %>% filter(is.cbp) %>% pull(Uniprot.ID) %>% unique() %>% length()`.

The number of RBPs is `r clf.ipr.matches.base %>% filter(is.rbp) %>% pull(Uniprot.ID) %>% unique() %>% length()`.

Some CBPs are RBPs as well.

Next, take only domain and disordered region matches overlapping with the peptides or residing no farther than 10 amino acids from either side of them:

```{r, include=T}
match.vicinity = 10 # amino acids

clf.ipr.matches.overlap = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Define functions for drawing peptide matches:

```{r, include=T}
draw_peptides = function(UniProtId) {
  x.axis.extension = 50
  y.axis.extension = 100
  ymin.const = 5
  ymax.const = 10
  
  protein.df = clf.ipr.matches.overlap %>%
    filter(Uniprot.ID == UniProtId) %>%
    dplyr::select(Sequence,
                  N.term.cleavage.window,
                  C.term.cleavage.window,
                  Start.position,
                  End.position) %>%
    mutate(ymin = ymin.const,
           ymax = ymax.const)
  
  protein.length = read.delim("input/Crosslinked_fraction_CLF_proteins.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
    filter(status == "T") %>%
    # Select domains that are integrated into InterPro (ipr.accession != "") and 
    # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
    filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
    # Parse the protein sequence headers and take the Uniprot IDs
    group_by(seq.id) %>%
    mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
    ungroup() %>%
    filter(uniprot.id == UniProtId) %>%
    pull(seq.length) %>%
    unique()
  
  ggplot(protein.df) +
    # Matches
    geom_rect(mapping = aes(xmin = Start.position,
                            xmax = End.position,
                            ymin = ymin,
                            ymax = ymax)) +
    # Protein C-terminal mark
    geom_vline(xintercept = protein.length) + 
    # Ruler
    scale_x_continuous(n.breaks = 7, 
                       limits = c(0, protein.length + x.axis.extension)) +
    # y scale
    scale_y_continuous(limits = c(0, ymax.const + y.axis.extension)) + 
    # Formatting
    theme_classic() + 
    theme(axis.line.y = element_blank(),
          axis.text.y = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.x = element_blank(),
          legend.position="none")
}
```

Draw matches for the example protein (A2A4P0):

```{r, include=T}
draw_peptides("A2A4P0")
```

Now we have `r clf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r clf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r clf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no farther than 10 amino acids from them) from `r clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Generate SPACEmap vs SPACE stats

Calculate the proportion of shared matched peptides:

```{r, include=T}
space.proteins = annot.table %>%
  pull(Uniprot.ID) %>%
  unique()

spacemap.proteins = peptide.table %>%
  pull(Uniprot.ID) %>%
  unique()

sp.sp2.intersection.proteins = intersect(space.proteins, spacemap.proteins)

sp.sp2.intersection.peptides = peptide.table %>%
  # Take only shared proteins
  filter(Uniprot.ID %in% sp.sp2.intersection.proteins) %>%
  # Take all peptides from the shared proteins - these are shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

sp.sp2.intersection.peptides.matched = sp.sp2.intersection.peptides %>%
  # Determine which shared peptides are matched
  left_join(clf.ipr.matches.overlap,
            by = c("Uniprot.ID",
                   "Sequence", 
                   "N.term.cleavage.window",
                   "C.term.cleavage.window")) %>%
  filter(!is.na(ipr.accession)) %>%
  # Take all matched shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()
```

There are `r length(space.proteins)` SPACE proteins and `r length(spacemap.proteins)` SPACEmap proteins. SPACE and SPACEmap have `r length(sp.sp2.intersection.proteins)` proteins in common. `r nrow(sp.sp2.intersection.peptides)` peptides come from the shared proteins, and `r nrow(sp.sp2.intersection.peptides.matched)` of these peptides match at least one domain or IDR. Hence, the proportion of matched peptides among all peptides from the shared proteins is `r nrow(sp.sp2.intersection.peptides.matched) / nrow(sp.sp2.intersection.peptides)`.

```{r}
annot.table.prev = read.delim("input/prev/mES_enriched_SPACE.tsv", 
                              header = T,
                              sep = "\t",
                              stringsAsFactors = F)

space.proteins.prev = annot.table.prev %>%
  pull(Uniprot.ID) %>%
  unique()

sp.sp2.intersection.proteins.prev = intersect(space.proteins.prev, spacemap.proteins)

sp.sp2.intersection.peptides.prev = peptide.table %>%
  # Take only shared proteins
  filter(Uniprot.ID %in% sp.sp2.intersection.proteins.prev) %>%
  # Take all peptides from the shared proteins - these are shared peptides
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct()

peptide.table %>%
  filter(Uniprot.ID %in% setdiff(unique(sp.sp2.intersection.peptides$Uniprot.ID),
                                 unique(sp.sp2.intersection.peptides.prev$Uniprot.ID))) %>%
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  #arrange(Uniprot.ID)
  nrow()

# calculate IPRs matched with the previous SPACE table
# find the difference between the current and the previous set of matched IDRs
# check that all such IDRs are matched by the peptides from the new SPACE proteins

#clf.ipr.matches.overlap %>%
  # check that some 
```

Write down the tables of shared peptides (all and matched):

```{r, include=T}
# Create the output directory, if it does not exist
dir.create("output")

# Load the table of peptides from SPACEmap for annotation purposes
peptide.table.whole = read.delim("input/Crosslinked_fraction_CLF.tsv",
                                 header = T,
                                 sep = "\t",
                                 stringsAsFactors = F)

# All shared peptides
write.table(sp.sp2.intersection.peptides %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_all.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Matched shared peptides
write.table(sp.sp2.intersection.peptides.matched %>%
              left_join(peptide.table.whole,
                        by = c("Uniprot.ID",
                               "Sequence", 
                               "N.term.cleavage.window",
                               "C.term.cleavage.window")),
            "output/space_spacemap-clf_shared_peptides_matched.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Select only chromatin- and RNA-binding proteins

From the whole table, select only CBPs and RBPs for further analysis:

```{r, include=T}
clf.ipr.matches.overlap.cbp_rbp = clf.ipr.matches.overlap %>%
  filter(is.cbp | is.rbp)

write.table(clf.ipr.matches.overlap.cbp_rbp,
            "output/clf_matches_in_cbp_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

We have `r clf.ipr.matches.overlap.cbp_rbp %>% filter(is.cbp) %>% pull(Uniprot.ID) %>% unique() %>% length()` CBPs and `r clf.ipr.matches.overlap.cbp_rbp %>% filter(is.rbp) %>% pull(Uniprot.ID) %>% unique() %>% length()` RBPs (some of these proteins are CBPs and RBPs at the same time). In total, we lost `r (clf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()) - (clf.ipr.matches.overlap.cbp_rbp %>%  pull(Uniprot.ID) %>% unique() %>% length())` as they are neither marked as CBPs nor as RBPs.

## Process matches in peptides from released fraction

Unsing InterProScan, we scanned all proteins containing at least one peptide from the SPACEmap released fraction, also captured by SPACE (see `scan_rf.sh`).

Read and process the results of scanning of proteins enriched in the released fraction of SPACEmap and also in SPACE:

```{r, include=T}
# Read in the InterProScan results
rf.ipr.matches = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.fa.tsv",
                             header = F,
                             colClasses = c("character",
                                            "character",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "numeric",
                                            "numeric",
                                            "character",
                                            "character",
                                            "character",
                                            "character",
                                            "character"),
                             col.names = c("seq.id",
                                           "md5",
                                           "seq.length",
                                           "db",
                                           "signature.accession",
                                           "signature.description",
                                           "start",
                                           "stop",
                                           "score",
                                           "status",
                                           "date",
                                           "ipr.accession",
                                           "ipr.description")) %>%
  filter(status == "T") %>%
  # Select domains that are integrated into InterPro (ipr.accession != "") and
  # disordered regions (db == "MobiDBLite"; they have empty ipr.accession)
  filter((ipr.accession != "") | (db == "MobiDBLite")) %>%
  # Parse the protein sequence headers and take the Uniprot IDs
  group_by(seq.id) %>%
  mutate(uniprot.id = unlist(stringr::str_split(seq.id, fixed("|")))[2]) %>%
  ungroup() %>%
  # Exclude matches from databases that do not contain domains or disordered regions
  filter(!db %in% c("ProSitePatterns",
                    "PRINTS",
                    "PIRSF",
                    "PANTHER")) %>%
  # Calculate consensus matches for domains and disordered regions
  group_by(uniprot.id, ipr.accession) %>%
  do(bind_cols(., find_consensus_matches(.$start, .$stop))) %>%
  ungroup() %>%
  mutate(int.start = int.start.cons) %>%
  mutate(int.stop = int.stop.cons) %>%
  distinct() %>%
  # Select only columns that we need for further analysis
  dplyr::select(uniprot.id,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description) %>%
  distinct() %>%
  arrange(uniprot.id,
          ipr.accession,
          as.numeric(int.start),
          as.numeric(int.stop))
```

We have `r rf.ipr.matches %>% filter(ipr.accession != "") %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches %>% filter(ipr.accession == "") %>% nrow()` predicted disordered regions in `r rf.ipr.matches %>% pull(uniprot.id) %>% unique() %>% length()` proteins.

Join the InterPro match table for the released fraction with the peptide for the same fraction:

```{r, include=T}
peptide.table.rf = read.delim("input/Released_fraction.txt_overlapped_with_SPACE.tsv",
                              header = T,
                              sep = "\t",
                              stringsAsFactors = F) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window,
                Start.position,
                End.position,
                logFC,
                Gene.names,
                Protein.names)

rf.ipr.matches.base = rf.ipr.matches %>%
  dplyr::rename(Uniprot.ID = uniprot.id) %>%
  left_join(peptide.table.rf,
            by = c("Uniprot.ID" = "Uniprot.ID"))
```

Next, take only domain and disordered region matches that overlap with a peptide or reside no farther than 10 amino acids from the ends of a peptide:

```{r, include=T}
match.vicinity = 10 # amino acids

rf.ipr.matches.overlap = rf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap)
```

Now we have `r rf.ipr.matches.overlap %>% filter(ipr.accession != "") %>% dplyr::select(Uniprot.ID, ipr.accession, int.start, int.stop) %>% distinct() %>% nrow()` domain matches and `r rf.ipr.matches.overlap %>% filter(ipr.accession == "") %>% dplyr::select(Uniprot.ID, int.start, int.stop) %>% distinct() %>% nrow()` predicted disordered regions overlapping with `r rf.ipr.matches.overlap %>% dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>% distinct() %>% nrow()` peptides (or residing no father than 10 amino acids from them) from `r rf.ipr.matches.overlap %>% pull(Uniprot.ID) %>% unique() %>% length()` proteins.

## Amino-acid frequencies in matched peptides

Calculate frequencies of amino acids from peptides matched in the crosslinked and released fractions. Do separate calculations for peptides matched to domains and to disordered regions (these two sets of peptides may overlap, as one and the same peptide could match both to a domain and to a disordered region). Also, calculate frequencies of amino acids in matches in all peptides (the full proteome).

```{r, include=T}
aa.names = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")

count_aas = function(aa.str) {
  aa.str.vec = strsplit(aa.str, "")[[1]]
  aa.counts = unlist(purrr::map(aa.names, 
                                function(x) {
                                  return(length(aa.str.vec[aa.str.vec == x]))
                                }))
  return(aa.counts)
}

# Frequencies of amino acids in domain-matching peptides from CLF
clf.ipr.matches.overlap.sequences.dom = clf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.clf.sum = sum(unique.aa.dict.dom.clf)
unique.aa.dict.dom.clf.freq = unlist(purrr::map(unique.aa.dict.dom.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.clf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from CLF
clf.ipr.matches.overlap.sequences.idr = clf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.clf = count_aas(purrr::reduce(clf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.clf.sum = sum(unique.aa.dict.idr.clf)
unique.aa.dict.idr.clf.freq = unlist(purrr::map(unique.aa.dict.idr.clf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.clf.sum
                                                }))

# Frequencies of amino acids in domain-matching peptides from RF
rf.ipr.matches.overlap.sequences.dom = rf.ipr.matches.overlap %>%
  filter(ipr.accession != "") %>% # select peptides with domain matches
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.dom.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.dom, paste0))
unique.aa.dict.dom.rf.sum = sum(unique.aa.dict.dom.rf)
unique.aa.dict.dom.rf.freq = unlist(purrr::map(unique.aa.dict.dom.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.dom.rf.sum
                                                }))

# Frequencies of amino acids in disordered region-matching peptides from RF
rf.ipr.matches.overlap.sequences.idr = rf.ipr.matches.overlap %>%
  filter(ipr.accession == "") %>% # select peptides with matches to disordered regions
  dplyr::select(Uniprot.ID,
                Sequence, 
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  pull(Sequence)

unique.aa.dict.idr.rf = count_aas(purrr::reduce(rf.ipr.matches.overlap.sequences.idr, paste0))
unique.aa.dict.idr.rf.sum = sum(unique.aa.dict.idr.rf)
unique.aa.dict.idr.rf.freq = unlist(purrr::map(unique.aa.dict.idr.rf, 
                                                function(x) {
                                                  x / unique.aa.dict.idr.rf.sum
                                                }))

# Table of the peptides from the full proteome
clf.peptides = annot.table %>%
  left_join(peptide.table, by = "Uniprot.ID") %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  filter(!is.na(Sequence)) %>%
  distinct()
rf.peptides = peptide.table.rf %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()
fp.peptides = clf.peptides %>%
  bind_rows(rf.peptides)

# Frequencies of amino acids in peptides from the full proteome (CLF + RF)
fp.sequences = fp.peptides %>%
  pull(Sequence)

unique.aa.dict.fp = count_aas(purrr::reduce(fp.sequences, paste0))
unique.aa.dict.fp.sum = sum(unique.aa.dict.fp)
unique.aa.dict.fp.freq = unlist(purrr::map(unique.aa.dict.fp, 
                                                function(x) {
                                                  x / unique.aa.dict.fp.sum
                                                }))
```

Plot the frequencies of amino acids from domain-matching peptides in CLF vs RF (Fig. 4F, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           rf = unique.aa.dict.dom.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids from disordered region-matching peptides in CLF vs RF (Fig. 4G, left):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           rf = unique.aa.dict.idr.rf.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = rf, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in domain-matching peptides from CLF vs full proteome (Fig. 4F, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.dom.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

Plot the frequencies of amino acids in disordered region-matching peptides in CLF vs full proteome (Fig. 4G, right):

```{r, include=T}
data.frame(clf = unique.aa.dict.idr.clf.freq * 100,
           fp = unique.aa.dict.fp.freq * 100,
           aa.names = aa.names) %>%
  ggplot(aes(x = fp, y = clf, label = aa.names)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    scale_x_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    scale_y_continuous(limits = c(0, 13), breaks = pretty_breaks(n = 13), expand = c(0, 0)) +
    ggrepel::geom_text_repel() +
    theme_classic()
```

## Find the most frequent InterPro entries

Plot the frequencies of the top matched InterPro entries:

```{r, include=T, fig.height=8}
uniprotid.db.total.num = clf.ipr.matches.overlap.cbp_rbp %>% 
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.freq = clf.ipr.matches.overlap.cbp_rbp %>%
  group_by(ipr.accession) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

clf.ipr.matches.overlap.cbp_rbp.freq %>%
  filter(uniprotid.freq >= 0.01) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "red") +
    scale_y_continuous(limits = c(0, 0.5), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the overall table of InterPro entry frequencies:

```{r, include=T}
write.table(clf.ipr.matches.overlap.cbp_rbp.freq,
            "output/clf_matches_in_db_and_rbp_freq.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Generalise (cluster) all matched InterPro entries

Do an automatical clusterisation of similar InterPro entries matched in CLF peptides (from CBPs and RBPs) shared between SPACEmap and SPACE: If two InterPro entries co-match at least once and in >=70% of co-matches they overlap by >=70% of their lengths, reciprocally, then we put them in one cluster (generalised entry). To maintain clusters, we use disjoint set union:

```{r, include=T}
tic("Clusterisation of matched InterPro entries")

good_overlap_fraction_cutoff = 0.7

overlap_size_cutoff = 0.7

ipr_overlap_list = list()

iprs = c()

i_overlaps_j = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  return(min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1 > 0)
}

i_overlaps_j_well = function(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop) {
  overlap_size = min(ipr_i_stop, ipr_j_stop) - max(ipr_i_start, ipr_j_start) + 1
  ipr_i_length = ipr_i_stop - ipr_i_start + 1
  ipr_j_length = ipr_j_stop - ipr_j_start + 1
  return((overlap_size >= overlap_size_cutoff * ipr_i_length) & 
         (overlap_size >= overlap_size_cutoff * ipr_j_length))
}

count_overlaps = function(gene_df) {
  gene_df = gene_df %>%
    dplyr::select(Uniprot.ID,
                  ipr.accession,
                  ipr.description,
                  int.start,
                  int.stop) %>%
    distinct()
  
  i = 0
  while (i < nrow(gene_df)) {
    i = i + 1
    ipr_i = as.character(gene_df[i, "ipr.accession"])
    ipr_i = ifelse(ipr_i == "", "disordered_region", ipr_i)
    iprs <<- c(iprs, ipr_i)
    j = i
    while (j < nrow(gene_df)) {
      j = j + 1
      ipr_j = as.character(gene_df[j, "ipr.accession"])
      ipr_j = ifelse(ipr_j == "", "disordered_region", ipr_j)
      iprs <<- c(iprs, ipr_j)
      if ((ipr_i != ipr_j) & (ipr_i != "disordered_region") & (ipr_j != "disordered_region")) {
        ipr_pair_name = paste0(ipr_i, "_", ipr_j)
        ipr_i_start = gene_df[i, "int.start"]
        ipr_i_stop = gene_df[i, "int.stop"]
        ipr_j_start = gene_df[j, "int.start"]
        ipr_j_stop = gene_df[j, "int.stop"]
        if (i_overlaps_j(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
          if (is.null(ipr_overlap_list[[ipr_pair_name]])) {
            ipr_overlap_list[[ipr_pair_name]] <<- list()
            ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- 0
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- 0
          }
          ipr_overlap_list[[ipr_pair_name]]$all_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$all_overlaps + 1
          if (i_overlaps_j_well(ipr_i_start, ipr_i_stop, ipr_j_start, ipr_j_stop)) {
            ipr_overlap_list[[ipr_pair_name]]$good_overlaps <<- ipr_overlap_list[[ipr_pair_name]]$good_overlaps + 1
          }
        }
      }
    }
  }
  iprs <<- unique(iprs)
}

# Form a list of overlapping IPR pairs
uniprot.ids = clf.ipr.matches.overlap.cbp_rbp %>%
  pull(Uniprot.ID) %>%
  unique()

for (uniprot.id in uniprot.ids) {
  count_overlaps(clf.ipr.matches.overlap.cbp_rbp %>% filter(Uniprot.ID == uniprot.id))
}

# Cluster InterPro entries by overlaps

# List to store disjoint sets
parent = list()

# List to store set ranks
set.size = list()

# DSU (Disjoint Set Union) functions
make_set = function(v) {
	parent[v] <<- v
	set.size[v] <<- 1
}

find_set = function(v) {
	if (v == unlist(parent[v])) {
	  return(v)
	}
	return(parent[v] <<- find_set(unlist(parent[v])))
}

merge_sets = function(a, b) {
	a = find_set(a)
	b = find_set(b)
	if (a != b) {
	  if (unlist(set.size[a]) > unlist(set.size[b])) {
	    parent[b] <<- a
	    set.size[a] <<- unlist(set.size[a]) + unlist(set.size[b])
	  } else {
	    parent[a] <<- b
	    set.size[b] <<- unlist(set.size[b]) + unlist(set.size[a])
	  }
	}
}

for (ipr in iprs) {
  make_set(ipr)
}

for (ipr_pair_name in names(ipr_overlap_list)) {
  if (ipr_overlap_list[[ipr_pair_name]]$good_overlaps / 
      ipr_overlap_list[[ipr_pair_name]]$all_overlaps >= 
      good_overlap_fraction_cutoff) {
    ipr_i = unlist(stringr::str_split(ipr_pair_name, "_"))[1]
    ipr_j = unlist(stringr::str_split(ipr_pair_name, "_"))[2]
    merge_sets(ipr_i, ipr_j)
  }
}

# Form the table of the found clusters
lead.ipr.table = data.frame(lead.ipr = unlist(parent),
                            ipr.accession = names(parent),
                            stringsAsFactors = F) %>%
  arrange(lead.ipr) %>%
  left_join(clf.ipr.matches.overlap.cbp_rbp %>%
              dplyr::select(ipr.accession,
                            ipr.description) %>%
              distinct(),
            by = c("ipr.accession"))

row.names(lead.ipr.table) = NULL

unique.lead.iprs = lead.ipr.table %>%
  pull(lead.ipr) %>%
  unique()

ipr.cluster.table = lead.ipr.table %>%
  left_join(data.frame(lead.ipr = unique.lead.iprs,
                       cluster.name = seq(1:length(unique.lead.iprs)),
                       stringsAsFactors = F),
            by = c("lead.ipr")) %>%
  dplyr::select(cluster.name,
                ipr.accession,
                ipr.description) %>%
  group_by(cluster.name) %>%
  mutate(cluster.size = length(ipr.accession)) %>%
  ungroup() %>%
  arrange(desc(cluster.size))

# Write down the table of all clusters
write.table(ipr.cluster.table,
            "output/match_clusters_in_db_and_rbp.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

toc()
# ~ 5 sec
```

Name clusters that are present in the plots below, according to the InterPro entries that these clusters contain:

```{r, include=T}
ipr.cluster.table = ipr.cluster.table %>%
  mutate(cluster.name = ifelse(cluster.name == "1", "Disordered region", cluster.name)) %>% # +
  mutate(cluster.name = ifelse(cluster.name == "526", "P-loop-related", cluster.name)) %>% # +
  mutate(cluster.name = ifelse(cluster.name == "592", "HTH", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "347", "RRM", cluster.name)) %>% # +
  mutate(cluster.name = ifelse(cluster.name == "293", "C2H2-type ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "265", "OB-fold", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "551", "RING/FYVE/PHD ZF", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "51", "Helicase, C-terminal", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "342", "Armadillo-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "317", "DEAD-box-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "52", "WD40 repeat", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "510", "SAM methyltransferase-related", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "99", "KH domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "32", "MCM domain", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "580", "C2H2 ZF-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "588", "WD40-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "463", "WD40/YVTN-containing", cluster.name)) %>%
  mutate(cluster.name = ifelse(cluster.name == "518", "MCM domain-containing", cluster.name))
```

## Find proportions of matched and unmatched CLF peptides from DNA- and RNA-binding proteins

First, find the number and proportion of all unmatched CLF peptides (from CBPs and RBPs) shared between SPACEmap and SPACE:

```{r, include=T}
clf.matched.peptides = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.all.peptides = clf.ipr.matches.base %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.unmatched.peptides = clf.all.peptides %>%
  dplyr::anti_join(clf.matched.peptides,
                   by = c("Uniprot.ID" = "Uniprot.ID",
                          "Sequence" = "Sequence",
                          "N.term.cleavage.window" = "N.term.cleavage.window",
                          "C.term.cleavage.window" = "C.term.cleavage.window"))
```

Hence, we have `r nrow(clf.unmatched.peptides)` unmatched peptides from SPACEmap CLF (`r round(nrow(clf.unmatched.peptides) / nrow(clf.all.peptides) * 100, 1)`% of all peptides from SPACEmap CLF).

## Find frequencies of cluster matches

First, apply our clusterisation to the main table with matched CLF peptides from CBPs and RBPs proteins:

```{r, include=T}
clf.ipr.matches.overlap.cbp_rbp.collated = clf.ipr.matches.overlap.cbp_rbp %>%
  mutate(ipr.accession = ifelse(ipr.accession == "", "disordered_region", ipr.accession)) %>%
  mutate(ipr.description = ifelse(ipr.description == "", "disordered_region", ipr.description)) %>%
  left_join(ipr.cluster.table %>%
              mutate(ipr.description = ifelse(is.na(ipr.description), "disordered_region", ipr.description)),
            by = c("ipr.accession", "ipr.description")) %>%
  filter(!is.na(cluster.name)) %>%
  mutate(ipr.accession = "") %>%
  mutate(ipr.description = cluster.name)
```

Secondly, generate tables with the frequencies of proteins and peptides with different matches (plot top 10 matches by frequency).

For the DNA-binding proteins (Fig. 4E; Fig. S4E, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.cbp = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.cbp) %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.cbp) %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.cbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq,
            "output/clf_cbp_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.cbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 60), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the RNA-binding proteins (Fig. 3D; Fig. S3D, left):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.rbp) %>%
  pull(Uniprot.ID) %>%
  unique() %>%
  length()

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.rbp) %>%
  group_by(ipr.description) %>%
  mutate(uniprotid.n = length(unique(Uniprot.ID))) %>%
  mutate(uniprotid.freq = uniprotid.n / uniprotid.db.total.num.collated.rbp) %>%
  ungroup() %>%
  arrange(desc(uniprotid.n)) %>%
  dplyr::select(ipr.accession, ipr.description, uniprotid.n, uniprotid.freq) %>%
  distinct() %>%
  mutate(ipr.description = ifelse(ipr.description == "",
                                  "Disordered region",
                                  ipr.description))

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq,
            "output/clf_rbp_protein_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(uniprotid.freq = uniprotid.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = uniprotid.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 50), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from DNA-binding proteins (Fig. S3E, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.db.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.cbp) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.cbp) %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.db.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides,
            "output/clf_db_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.db_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "dark green") +
    scale_y_continuous(limits = c(0, 40), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

For the peptides from RNA-binding proteins (Fig. S3D, right):

```{r, include=T, fig.height=5, fig.width=5}
uniprotid.db.total.num.collated.rbp.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>% 
  filter(is.rbp) %>%
  dplyr::select(Uniprot.ID,
                Sequence,
                N.term.cleavage.window,
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides = clf.ipr.matches.overlap.cbp_rbp.collated %>%
  filter(is.rbp) %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  mutate(peptide.id = paste(Uniprot.ID, 
                            Sequence, 
                            N.term.cleavage.window, 
                            C.term.cleavage.window,
                            sep = "_")) %>%
  ungroup() %>%
  group_by(ipr.description) %>%
  mutate(peptide.id.n = length(unique(peptide.id))) %>%
  mutate(peptide.id.freq = peptide.id.n / uniprotid.db.total.num.collated.rbp.peptides) %>%
  ungroup() %>%
  arrange(desc(peptide.id.n)) %>%
  dplyr::select(ipr.accession, ipr.description, peptide.id.n, peptide.id.freq) %>%
  distinct()

write.table(clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides,
            "output/clf_rbp_peptide_match_frequencies.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq.peptides %>%
  head(10) %>%
  mutate(ipr.description = factor(ipr.description, levels = ipr.description)) %>%
  mutate(peptide.id.freq = peptide.id.freq * 100) %>%
  ggplot(aes(x = ipr.description, y = peptide.id.freq)) +
    geom_col(fill = "purple") +
    scale_y_continuous(limits = c(0, 30), breaks = pretty_breaks(n = 5)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Write down the table of generalised entries:

```{r, include=T}
write.table(ipr.cluster.table,
            "output/cluster_table.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

## Compare top structural domain types in DNA- and RNA-binding proteins

Take top 5 structural domain types (the general clusters that we found above) in DNA- and RNA-binding proteins and compare their abundance in both groups (Figure S3F):

```{r, include=T}
# Select top 5 matched domain types from DBPs and RBPs, and merge these domain types in one set.
# Let us exclude disordered region matches as here we are interested in domains.
top.matched.domains = unique(c(clf.ipr.matches.overlap.cbp_rbp.collated.db_freq %>%
                                 arrange(desc(uniprotid.freq)) %>%
                                 head(6) %>% # 5 without IDRs
                                 pull(ipr.description),
                               clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq %>%
                                 arrange(desc(uniprotid.freq)) %>%
                                 head(6) %>% # 5 without IDRs
                                 pull(ipr.description)))

freq.in.dbp_rbp = clf.ipr.matches.overlap.cbp_rbp.collated.db_freq %>%
  filter(ipr.description %in% top.matched.domains) %>%
  dplyr::rename("uniprotid.n.dbp" = "uniprotid.n",
                "uniprotid.freq.dbp" = "uniprotid.freq") %>%
  dplyr::select(-ipr.accession) %>%
  dplyr::full_join(clf.ipr.matches.overlap.cbp_rbp.collated.rbp_freq %>%
                     filter(ipr.description %in% top.matched.domains) %>%
                     dplyr::rename("uniprotid.n.rbp" = "uniprotid.n",
                                   "uniprotid.freq.rbp" = "uniprotid.freq") %>%
                     dplyr::select(-ipr.accession),
                   by = c("ipr.description" = "ipr.description")) %>%
  tidyr::replace_na(list(uniprotid.n.dbp = 0, 
                         uniprotid.freq.dbp = 0,
                         uniprotid.n.rbp = 0,
                         uniprotid.freq.rbp = 0)) %>%
  arrange(desc(uniprotid.freq.dbp)) %>%
  filter(ipr.description != "Disordered region")

top.matched.domains.ordered = freq.in.dbp_rbp$ipr.description

# Plot the top 5 matched domain types, sorted by decreasing abundance in DBPs
data.frame(domain.type = rep(top.matched.domains.ordered, 2),
           protein.category = c(rep("DBP", length(top.matched.domains.ordered)),
                                rep("RBP", length(top.matched.domains.ordered))),
           protein.freq = c(freq.in.dbp_rbp$uniprotid.freq.dbp,
                            freq.in.dbp_rbp$uniprotid.freq.rbp)) %>%
  mutate(domain.type = factor(domain.type, levels = top.matched.domains.ordered)) %>%
  mutate(protein.freq = protein.freq * 100) %>%
  ggplot(aes(x = domain.type, y = protein.freq)) +
    geom_col(aes(fill = protein.category), position = "dodge2") +
    scale_y_continuous(limits = c(0, 12), breaks = pretty_breaks(n = 7)) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

Interestingly, the P-loop-related domains are the top matches, equally frequent in DBPs and RBPs. Although P-loops have been known for a long time as NTP-binding motifs frequently present in various NTP hydrolases ([Vetter and Wittinghofer, 1999](https://www.cambridge.org/core/journals/quarterly-reviews-of-biophysics/article/nucleoside-triphosphatebinding-proteins-different-scaffolds-to-achieve-phosphoryl-transfer/DCF7EEE392136BE87CD82FF3AAD866EC)), recently ([Romero et al., 2018](https://www.pnas.org/content/115/51/E11943)) showed that P-loops can also bind DNA and RNA. Helix-turn-helix (HTH) and C2H2-type ZF clusters are characteristic of DBPs, which corresponds to the well-known DNA-binding role of these domains ([Brennan and Matthews, 1989](https://www.sciencedirect.com/science/article/pii/S0021925818941153); [Wolfe, Nekludova and Pabo, 2000](https://www.annualreviews.org/doi/10.1146/annurev.biophys.29.1.183)). Another top matching cluster, the OB-fold, is also more common in DBPs, but is comparably frequent in RBPs. Indeed, it contains the RNA-binding S1 domain ([Bycroft et al., 1997](https://www.sciencedirect.com/science/article/pii/S0092867400818449)), the cold shock domain capable of both DNA- and RNA-binding ([Lindquist and Mertens, 2018](https://biosignaling.biomedcentral.com/articles/10.1186/s12964-018-0274-6)), and ribosomal proteins that may contact rRNA. Other top clusters match more frequently in RBPs. Namely, the RNA recognition motif (RRM) is almost two times more frequent in RBPs than in DBPs, in accord with its definition. It can also bind single-strand DNA ([Ding et al., 1999](http://genesdev.cshlp.org/content/13/9/1102.long)), which may explain its still considerable frequency in DBPs. Next, the domains from the "Helicase, C-terminal" cluster have not as yet been shown to bind DNA; however, as part of DNA and RNA helicases, they could contact both types of nucleic acid molecules. The other two clusters more frequent in RBPs are the Armadillo-related and the  DEAD-box-related ones. In the Armadillo-related cluster, both the Pumillo homology domain and the MIF4G domains are known RNA binders ([Wang et al., 2002](https://www.sciencedirect.com/science/article/pii/S0092867402008735); [Marintchev and Wagner, 2005](https://pubs.acs.org/doi/10.1021/bi051271v)). Some other entries in this cluster represent domains from translation factors or nucleolus-localised proteins; hence, these domains, not as yet shown to be DNA or RNA binders, could indeed bind DNA or RNA molecules. Finally, entries from the DEAD-box-related cluster also have not been shown to bind RNA, although they belong to RNA and DNA helicases, and one of the entries (IPR014001) describes a DNA-binding domain. Overall, SPACEmap detects both known and possible novel DNA- and RNA-binding domains.

## Study unmatched CLF peptides from SPACEmap

Unmatched CLF peptides from SPACEmap may have motifs representing as yet undiscovered domains. Let us scan the unmatched peptide sequences with MeMe. For this, we need to prepare the sequences first: (a) merge N- and C-terminal flanks with the peptide sequences by overlaps (so that if a motif goes into flanks, it would be captured); (b) merge the combined sequences from the same protein by overlaps (we want to avoid a situation when a motif is deemed significant just because it is constructed from overlapping peptide sequences); (c) filter out sequences that are shorter than 8 amino acids (MEME's threshold for sequence length). Let us prepare the sequences:

```{r, include=T}
# Merge two strings by an overlap or concatenate them if there is no overlap
str_merge = function(str1, str2) {
  if ((str1 == "") & (str2 == "")) {
    return("")
  }
  if (str1 == "") {
    return(str2)
  }
  if (str2 == "") {
    return(str1)
  }
  if (stringr::str_detect(str1, fixed(str2))) {
    return(str1)
  }
  if (stringr::str_detect(str2, fixed(str1))) {
    return(str2)
  }
  str1_length = nchar(str1)
  str2_length = nchar(str2)
  max_prefix_coordinate = 0
  for (i in seq(0, min(str1_length, str2_length) - 1)) {
    if (substr(str1, str1_length - i, str1_length) == substr(str2, 1, i + 1)) {
      max_prefix_coordinate = i + 1
    }
  }
  if (max_prefix_coordinate == 0) {
    return(paste0(str1, str2))
  }
  return(paste0(str1, substr(str2, max_prefix_coordinate + 1, str2_length)))
}

# Assemble sequences by overlaps
calc_str_merge = function(str1, str2) {
  if (stringr::str_detect(str1, fixed(str2))) {
    return(list("length" = nchar(str2),
                "merge" = str1))
  }
  if (stringr::str_detect(str2, fixed(str1))) {
    return(list("length" = nchar(str1),
                "merge" = str2))
  }
  str1_length = nchar(str1)
  str2_length = nchar(str2)
  max_prefix_coordinate = 0
  for (i in seq(0, min(str1_length, str2_length) - 1)) {
    if (substr(str1, str1_length - i, str1_length) == substr(str2, 1, i + 1)) {
      max_prefix_coordinate = i + 1
    }
  }
  return(list("length" = max_prefix_coordinate,
              "merge" = paste0(str1, substr(str2, max_prefix_coordinate + 1, str2_length))))
}

merge_sequences = function(sequence.lead, sequence.lag) {
  merge.list.lead.lag = calc_str_merge(sequence.lead, sequence.lag)
  merge.list.lag.lead = calc_str_merge(sequence.lag, sequence.lead)
  if (merge.list.lead.lag[["length"]] >= merge.list.lag.lead[["length"]]) {
    return(merge.list.lead.lag)
  }
  return(merge.list.lag.lead)
}

assemble_by_overlaps = function(uniprotid,
                                input.sequences) {
  if (length(input.sequences) == 1) {
    return(data.frame(Uniprot.ID = uniprotid, 
                      contigs = input.sequences[1], 
                      status = "original",
                      stringsAsFactors = F))
  }
  overlap.size.cutoff = 5
  sequences.to.assemble = input.sequences
  contigs.to.report = c()
  status.list = list()
  for (input.sequence in input.sequences) {
    status.list[[input.sequence]] = "original"
  }
  contig.status.list = list()
  while (length(sequences.to.assemble) > 1) {
    sequence.lead = sequences.to.assemble[1]
    max.overlap.length = 0
    max.overlap.index = 0
    max.overlap.sequence.lag = ""
    max.overlap.merge = ""
    for (lag.i in 2:(length(sequences.to.assemble))) {
      sequence.lag = sequences.to.assemble[lag.i]
      merge.list = merge_sequences(sequence.lead, sequence.lag)
      overlap.length = merge.list[["length"]]
      overlap.merge = merge.list[["merge"]]
      if (overlap.length > max.overlap.length) {
        max.overlap.length = overlap.length
        max.overlap.index = lag.i
        max.overlap.sequence.lag = sequence.lag
        max.overlap.merge = overlap.merge
      }
    }
    if (max.overlap.length >= overlap.size.cutoff) {
      sequences.to.assemble = sequences.to.assemble[-max.overlap.index]
      status.list[[max.overlap.sequence.lag]] = NULL
      sequences.to.assemble = sequences.to.assemble[-1]
      status.list[[sequence.lead]] = NULL
      sequences.to.assemble[length(sequences.to.assemble) + 1] = max.overlap.merge
      status.list[[max.overlap.merge]] = "merged"
    } else {
      sequences.to.assemble = sequences.to.assemble[-1]
      contigs.to.report[length(contigs.to.report) + 1] = sequence.lead
      contig.status.list[length(contig.status.list) + 1] = status.list[[sequence.lead]]
      status.list[[sequence.lead]] = NULL
    }
  }
  contigs.to.report[length(contigs.to.report) + 1] = sequences.to.assemble[1]
  contig.status.list[length(contig.status.list) + 1] = status.list[1]
  
  return(data.frame(Uniprot.ID = rep(uniprotid, length(sequences.to.assemble)), 
                    contigs = contigs.to.report, 
                    status = unlist(contig.status.list), 
                    stringsAsFactors = F))
}

clf.all.matched.peptides = clf.ipr.matches.base %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.all.peptides = clf.ipr.matches.base %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  distinct()

clf.all.unmatched.peptides = clf.all.peptides %>%
  dplyr::anti_join(clf.all.matched.peptides,
                   by = c("Uniprot.ID" = "Uniprot.ID",
                          "Sequence" = "Sequence",
                          "N.term.cleavage.window" = "N.term.cleavage.window",
                          "C.term.cleavage.window" = "C.term.cleavage.window"))

clf.all.unmatched.peptides.merged = clf.all.unmatched.peptides %>%
    group_by(Uniprot.ID,
             Sequence,
             N.term.cleavage.window,
             C.term.cleavage.window) %>%
    do(mutate(., peptide.sequence = str_merge(
                                      str_merge(
                                        stringr::str_replace_all(.$N.term.cleavage.window, "_", ""),
                                        stringr::str_replace_all(.$Sequence, "_", "")),
                                      stringr::str_replace_all(.$C.term.cleavage.window, "_", "")))) %>%
  ungroup()

tic("Assemble peptide sequences")
clf.all.unmatched.peptides.merged.assembled = dplyr::bind_rows(purrr::map(clf.all.unmatched.peptides.merged %>%
                                                                            pull(Uniprot.ID) %>%
                                                                            unique(),
                                                                          function(uniprotid) {
                                                                            assemble_by_overlaps(uniprotid,
                                                                                                 clf.all.unmatched.peptides.merged %>%
                                                                                                   filter(Uniprot.ID == uniprotid) %>%
                                                                                                   pull(peptide.sequence))
                                                                          }))
toc()
# ~ 0.7 sec

# Filter out short sequences and form sequence headers for FASTA
clf.all.unmatched.peptides.merged.assembled.final = clf.all.unmatched.peptides.merged.assembled %>%
  filter(nchar(contigs) > 8) %>%
  group_by(Uniprot.ID) %>%
  mutate(fasta.header = paste(Uniprot.ID, as.character(row_number()), sep = "_")) %>%
  ungroup()

# Write down the final table
write.table(clf.all.unmatched.peptides.merged.assembled.final,
            "output/final_assembled_peptide_sequences_clf.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

# Write down FASTA with the final sequences
write.fasta(as.list(clf.all.unmatched.peptides.merged.assembled.final %>%
                      pull(contigs)),
            as.list(clf.all.unmatched.peptides.merged.assembled.final %>%
                      pull(fasta.header)),
            "output/final_assembled_peptide_sequences_clf.fa")
```

We searched motifs _de novo_ in the sequences from the FASTA file using MeMe Suite v5.3.3 with default options, but did not find any significant motifs at the level of e-value < 0.05 (see output/meme_reports).

## Calculate peptide abundance in DBDs vs CLF/RF intensity ratio

Upload the table of DBDs (was obtained for human transcription factors):

```{r, include=T}
dbd.table = read.delim("input/dbd_table_manually_annotated.tsv")
```

Generate the overall table of SPACEmap peptides from matched proteins, and also captured by SPACE:

```{r, include=T}
all.ipr.matches.base = bind_rows(clf.ipr.matches.base %>%
                                   dplyr::select(-Category, -RBP) %>%
                                   mutate(fraction.type = "CLF"),
                                 rf.ipr.matches.base %>%
                                   mutate(fraction.type = "RF"))
```

Join the overall table of peptides with the table of classical DBDs from human TFs:

```{r, include=T}
all.ipr.matches.base.dbd = all.ipr.matches.base %>%
  left_join(dbd.table,
            by = c("ipr.accession" = "ipr_accession",
                   "ipr.description" = "ipr_description"))
```

Mark each peptide as matched or unmatched:

```{r, include=T}
match.vicinity = 10
all.ipr.matches.base.dbd.marked = all.ipr.matches.base.dbd %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  mutate(category = ifelse(is.na(category), "", category)) %>%
  mutate(match.dbd.overlap = (match.peptide.overlap & category == "DBD")) %>%
  group_by(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window) %>%
  mutate(match.dbd.overlap = sum(match.dbd.overlap)) %>%
  ungroup() %>%
  mutate(match.dbd.overlap = ifelse(match.dbd.overlap >= 1, 1, 0)) %>%
  dplyr::select(Uniprot.ID, Sequence, N.term.cleavage.window, C.term.cleavage.window,
                match.peptide.overlap, match.dbd.overlap, logFC,
                represents_family, fraction.type) %>%
  distinct() %>%
  filter(match.peptide.overlap)
```

Calculate ratios of CLF and RF peptides that overlap with the classical DBDs:

```{r, include=T}
cat("CLF:", (all.ipr.matches.base.dbd.marked %>%
      filter(fraction.type == "CLF") %>%
      filter(match.dbd.overlap == 1) %>%
      nrow()) / 
      (all.ipr.matches.base.dbd.marked %>%
         filter(fraction.type == "CLF") %>%
         nrow()), "\n")
cat("RF:", (all.ipr.matches.base.dbd.marked %>%
      filter(fraction.type == "RF") %>%
      filter(match.dbd.overlap == 1) %>%
      nrow()) / 
      (all.ipr.matches.base.dbd.marked %>%
         filter(fraction.type == "RF") %>%
         nrow()), "\n")
```

## Stratify all CLF peptides by matches

Count CLF peptides (from DNA- and RNA-binding proteins) that match domains, IDRs, and those who do not match any feature:

```{r, include=T}
# First, we ran `classify_domains.py` to obtain a table of all InterPro v82 entries classified into "Putative DBD" (if the word "DNA" is present in the entry) and "Other" (if the word "DNA" is not present in the entry). In this way, we obtained the `output/interpro82_domain_binary_classification.tsv` table.
ipr.draft.classes = read.delim("output/interpro82_domain_binary_classification.tsv")

clf.peptides.coord = annot.table %>%
  left_join(peptide.table, by = "Uniprot.ID") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window,
                Start.position,
                End.position,
                Category,
                RBP) %>%
  filter(!is.na(Sequence)) %>%
  filter(is.cbp | is.rbp) %>%
  distinct()

match.vicinity = 10 # amino acids

clf.peptides.matches = clf.peptides.coord %>%
  left_join(clf.ipr.matches,
            by = c("Uniprot.ID" = "uniprot.id")) %>%
  left_join(ipr.draft.classes,
            by = c("ipr.accession" = "ipr_accession")) %>%
  dplyr::rename("IPR.category" = "category") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window, 
                Start.position, 
                End.position,
                Category,
                RBP,
                int.start,
                int.stop,
                ipr.accession,
                ipr.description,
                IPR.category) %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  mutate(matched.feature = ifelse(!match.peptide.overlap, 
                                  "None",
                                  ifelse(ipr.accession == "",
                                         "IDR",
                                         ifelse(IPR.category == "DNA-related",
                                                "Domain, DNA-related",
                                                "Domain, Other")))) %>%
  group_by(Uniprot.ID, 
           Sequence, 
           N.term.cleavage.window, 
           C.term.cleavage.window) %>%
  do(mutate(., matched = ifelse(("Domain, DNA-related" %in% .$matched.feature | "Domain, Other" %in% .$matched.feature) & 
                                 "IDR" %in% .$matched.feature,
                                "Domain+IDR",
                                ifelse("Domain, DNA-related" %in% .$matched.feature & "Domain, Other" %in% .$matched.feature,
                                       "Domain, DNA-related + Other",
                                       ifelse("Domain, DNA-related" %in% .$matched.feature,
                                              "Domain, DNA-related",
                                              ifelse("Domain, Other" %in% .$matched.feature,
                                                     "Domain, Other",
                                                     ifelse("IDR" %in% .$matched.feature,
                                                            "IDR",
                                                            "None"))))))) %>%
  ungroup()

# Final match table
write.table(clf.peptides.matches,
            file = "output/dbp_rbp_clf_peptide_matches_stratified.tsv",
            quote = F,
            sep = "\t",
            row.names = F)

```

Compare the frequencies of Domain-, IDR- and (Domain+IDR)-matching and unmatched peptides in DBPs and RBPs:

```{r, include=T}
clf.peptides.matches.stratified = clf.peptides.matches

peptides.matched.domain_dna_related.n.db = clf.peptides.matches.stratified %>% 
  filter(is.cbp) %>%
  filter(matched == "Domain, DNA-related") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_other.n.db = clf.peptides.matches.stratified %>% 
  filter(is.cbp) %>%
  filter(matched == "Domain, Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_both.n.db = clf.peptides.matches.stratified %>% 
  filter(is.cbp) %>%
  filter(matched == "Domain, DNA-related + Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_dna_related.n.rbp = clf.peptides.matches.stratified %>% 
  filter(is.rbp) %>%
  filter(matched == "Domain, DNA-related") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_other.n.rbp = clf.peptides.matches.stratified %>% 
  filter(is.rbp) %>%
  filter(matched == "Domain, Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_both.n.rbp = clf.peptides.matches.stratified %>% 
  filter(is.rbp) %>%
  filter(matched == "Domain, DNA-related + Other") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.idr.n.db = clf.peptides.matches.stratified %>% 
  filter(is.cbp) %>%
  filter(matched == "IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.idr.n.rbp = clf.peptides.matches.stratified %>% 
  filter(is.rbp) %>%
  filter(matched == "IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_idr.n.db = clf.peptides.matches.stratified %>% 
  filter(is.cbp) %>%
  filter(matched == "Domain+IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.domain_idr.n.rbp = clf.peptides.matches.stratified %>% 
  filter(is.rbp) %>%
  filter(matched == "Domain+IDR") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.none.n.db = clf.peptides.matches.stratified %>% 
  filter(is.cbp) %>%
  filter(matched == "None") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.none.n.rbp = clf.peptides.matches.stratified %>% 
  filter(is.rbp) %>%
  filter(matched == "None") %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.all.n.db = clf.peptides.matches.stratified %>% 
  filter(is.cbp) %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

peptides.matched.all.n.rbp = clf.peptides.matches.stratified %>% 
  filter(is.rbp) %>%
  dplyr::select(Uniprot.ID, 
                Sequence, 
                N.term.cleavage.window, 
                C.term.cleavage.window) %>%
  distinct() %>%
  nrow()

cat("DBPs:\n")
cat("Domain, DNA-related:", 
    peptides.matched.domain_dna_related.n.db, 
    paste0("(", round(peptides.matched.domain_dna_related.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("Domain, Other      :", 
    peptides.matched.domain_other.n.db, 
    paste0("(", round(peptides.matched.domain_other.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("Domain, both       :", 
    peptides.matched.domain_both.n.db, 
    paste0("(", round(peptides.matched.domain_both.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("Domain+IDR         :", 
    peptides.matched.domain_idr.n.db, 
    paste0("(", round(peptides.matched.domain_idr.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("IDR                :", 
    peptides.matched.idr.n.db, 
    paste0("(", round(peptides.matched.idr.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))
cat("None               :", 
    peptides.matched.none.n.db, 
    paste0("(", round(peptides.matched.none.n.db / peptides.matched.all.n.db * 100, 2), "%)\n"))

cat("RBPs:\n")
cat("Domain, DNA-related:", 
    peptides.matched.domain_dna_related.n.rbp, 
    paste0("(", round(peptides.matched.domain_dna_related.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("Domain, Other      :", 
    peptides.matched.domain_other.n.rbp, 
    paste0("(", round(peptides.matched.domain_other.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("Domain, both       :", 
    peptides.matched.domain_both.n.rbp, 
    paste0("(", round(peptides.matched.domain_both.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("Domain+IDR         :", 
    peptides.matched.domain_idr.n.rbp, 
    paste0("(", round(peptides.matched.domain_idr.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("IDR                :", 
    peptides.matched.idr.n.rbp, 
    paste0("(", round(peptides.matched.idr.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))
cat("None               :", 
    peptides.matched.none.n.rbp, 
    paste0("(", round(peptides.matched.none.n.rbp / peptides.matched.all.n.rbp * 100, 2), "%)\n"))

data.frame(category = rep(c("Domain, DNA-related", "Domain, Other", "Domain, both", "Domain+IDR", "IDR", "None"), 2),
           feature = c(rep("DBPs", 6), rep("RBPs", 6)),
           fraction = c(peptides.matched.domain_dna_related.n.db  / peptides.matched.all.n.db,
                        peptides.matched.domain_other.n.db        / peptides.matched.all.n.db,
                        peptides.matched.domain_both.n.db         / peptides.matched.all.n.db,
                        peptides.matched.domain_idr.n.db          / peptides.matched.all.n.db,
                        peptides.matched.idr.n.db                 / peptides.matched.all.n.db,
                        peptides.matched.none.n.db                / peptides.matched.all.n.db,
                        peptides.matched.domain_dna_related.n.rbp / peptides.matched.all.n.rbp,
                        peptides.matched.domain_other.n.rbp       / peptides.matched.all.n.rbp,
                        peptides.matched.domain_both.n.rbp        / peptides.matched.all.n.rbp,
                        peptides.matched.domain_idr.n.rbp         / peptides.matched.all.n.rbp,
                        peptides.matched.idr.n.rbp                / peptides.matched.all.n.rbp,
                        peptides.matched.none.n.rbp               / peptides.matched.all.n.rbp)) %>%
  mutate(category = factor(category, levels = c("Domain, DNA-related", 
                                                "Domain, Other", 
                                                "Domain, both",
                                                "Domain+IDR", 
                                                "IDR", 
                                                "None"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

Visually inspect simultaneous matches of DNA-related and Other domains:

```{r, include=T}
clf.peptides.matches.stratified %>%
  filter(matched == "Domain, DNA-related + Other") %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(-Category, -RBP, -match.peptide.overlap, -matched.feature)
```

There are a lot of peptides that match a DNA-related and an Other domain at the same time. From the visual inspection of the `clf.peptides.matches.stratified` table, it is clear that these peptides are matched by domains of different generality in the InterPro hierarchy or by a domain and a superfamily one of which is qualified as DNA-related and the other - as Other. Hence, stratification of domains into DNA-related and Other does not make much sense, and we need to stick to the general "Domain" group and manually curate all domains to gain insight into their relevance to chromatin.

Plot the same frequencies with all domains in one group:

```{r, include = T}
data.frame(category = rep(c("Domain", "Domain+IDR", "IDR", "None"), 2),
           feature = c(rep("DBPs", 4), rep("RBPs", 4)),
           fraction = c((peptides.matched.domain_dna_related.n.db + 
                           peptides.matched.domain_other.n.db + 
                           peptides.matched.domain_both.n.db) / 
                          peptides.matched.all.n.db,
                        peptides.matched.domain_idr.n.db          / peptides.matched.all.n.db,
                        peptides.matched.idr.n.db                 / peptides.matched.all.n.db,
                        peptides.matched.none.n.db                / peptides.matched.all.n.db,
                        (peptides.matched.domain_dna_related.n.rbp + 
                           peptides.matched.domain_other.n.rbp + 
                           peptides.matched.domain_both.n.rbp) / 
                          peptides.matched.all.n.rbp,
                        peptides.matched.domain_idr.n.rbp         / peptides.matched.all.n.rbp,
                        peptides.matched.idr.n.rbp                / peptides.matched.all.n.rbp,
                        peptides.matched.none.n.rbp               / peptides.matched.all.n.rbp)) %>%
  mutate(category = factor(category, levels = c("Domain",
                                                "Domain+IDR", 
                                                "IDR", 
                                                "None"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

Generate a base table of peptide matches, without domain stratification:

```{r, include=T}
clf.peptides.matches.unstratified = clf.peptides.matches %>%
  mutate(matched = ifelse(stringr::str_detect(matched, "Domain,"),
                          "Domain",
                          matched))

# Final match table, base
write.table(clf.peptides.matches.unstratified,
            file = "output/dbp_rbp_clf_peptide_matches_unstratified.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Prepare the draft classification table of InterPro entries matched to CLF peptides from DNA- and RNA-binding proteins:

```{r, include=T}
ipr.draft.classes.clf = clf.peptides.matches %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(ipr.accession,
                ipr.description) %>%
  distinct() %>%
  left_join(ipr.draft.classes,
            by = c("ipr.accession" = "ipr_accession")) %>%
  filter(!is.na(category))

write.table(ipr.draft.classes.clf,
            "output/ipr_draft_classes_clf.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

Check the proportions of "DNA-related" and "Other" InterPro entries among all matched entries:

```{r, include=T}
ipr.draft.classes.clf.dna_related.n = ipr.draft.classes.clf %>%
  filter(category == "DNA-related") %>%
  pull(ipr.accession) %>%
  unique() %>%
  length()

ipr.draft.classes.clf.all.n = ipr.draft.classes.clf %>%
  pull(ipr.accession) %>%
  unique() %>%
  length()

cat("Number of DNA-related entries:", 
    ipr.draft.classes.clf.dna_related.n, 
    paste0("(", round(ipr.draft.classes.clf.dna_related.n / ipr.draft.classes.clf.all.n * 100, 2), "%)\n"))

data.frame(category = c("DNA-related", "Other"),
           feature = rep("Matched InterPro entries", 2),
           fraction = c(ipr.draft.classes.clf.dna_related.n / ipr.draft.classes.clf.all.n,
                        1 - ipr.draft.classes.clf.dna_related.n / ipr.draft.classes.clf.all.n)) %>%
  mutate(category = factor(category, levels =  c("DNA-related", "Other"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

## Check CLF peptides in known DBDs

Select DBPs with known DBDs:

```{r, include=T}
clf.ipr.matches.base.dbd_matches = clf.ipr.matches.base %>%
  filter(is.cbp) %>%
  filter(ipr.accession %in% dbd.table$ipr_accession) %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  group_by(Uniprot.ID) %>%
  do(mutate(., dbd.matched = Reduce(function(x, y) x | y, .$match.peptide.overlap))) %>%
  ungroup()

matched.proteins = clf.ipr.matches.base.dbd_matches %>%
  filter(dbd.matched) %>%
  pull(Uniprot.ID) %>%
  unique()

unmatched.proteins = clf.ipr.matches.base.dbd_matches %>%
  filter(!dbd.matched) %>%
  pull(Uniprot.ID) %>%
  unique()

matched.proteins.n = length(matched.proteins)

unmatched.proteins.n = length(unmatched.proteins)

all.proteins = clf.ipr.matches.base.dbd_matches %>%
  pull(Uniprot.ID) %>%
  unique()

all.proteins.n = length(all.proteins)

data.frame(category = c("Matched DBD", "Unmatched DBD"),
           feature = c("DBPs and RBPs with DBDs"),
           fraction = c(matched.proteins.n / all.proteins.n,
                        unmatched.proteins.n / all.proteins.n)) %>%
  mutate(category = factor(category, levels = c("Matched DBD", "Unmatched DBD"))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

Check DBPs where known DBDs are not matched by CLF peptides:

```{r, include=T}
unmatched.proteins.other_matches = clf.ipr.matches.base %>%
  filter(is.cbp) %>%
  filter(Uniprot.ID %in% unmatched.proteins) %>%
  mutate(int.start = as.integer(int.start),
         int.stop = as.integer(int.stop)) %>%
  mutate(match.peptide.overlap = (if_else(int.stop < End.position,
                                          int.stop,
                                          End.position) - 
                                  if_else(int.start > Start.position,
                                          int.start,
                                          Start.position) >= 
                                  -match.vicinity - 1)) %>%
  group_by(Uniprot.ID) %>%
  do(mutate(., site.matched = Reduce(function(x, y) x | y, .$match.peptide.overlap))) %>%
  ungroup()

unmatched.proteins.other_matches %>%
  filter(site.matched)

unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap)

unmatched.proteins.other_matches %>%
  filter(!site.matched)
```

Check how many proteins are matched by each of the non-DBD entries:

```{r, include=T}
other.matches = unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, ipr.accession, ipr.description) %>%
  distinct() %>%
  group_by(ipr.accession, ipr.description) %>%
  do(mutate(., n = nrow(.))) %>%
  ungroup() %>%
  dplyr::select(-Uniprot.ID) %>%
  distinct() %>%
  arrange(desc(n)) 

other.matches
```

Most probably, these domains do not bind DNA. However, these non-DBD entries can still be relevant to chromatin, and proteins from which they come may have been bound to other chromatin proteins via these non-DBDs or IDRs, or use their IDRs to bind to DNA. 

Write down the table of non-DBD matches to manually classify them into those expected and unexpected for chromatin proteins:

```{r, include=T}
write.table(other.matches,
            "output/space_spacemap-clf_shared_peptides_dbps_nondbds.tsv",
            quote = F,
            sep = "\t",
            row.names = F)
```

We manually classified these non-DBDs into those expected and unexpected to be matched by the crosslinked peptides from a SPACEmap experiment (see the classification in `space_spacemap-clf_shared_peptides_dbps_nondbds_final.tsv`). We will use this classification below, in the overall plot of different fractions of proteins.

Plot the final frequencies of DBPs with DBDs, that 

1) Have CLF peptides from DBDs.

2) Do not have CLF peptides from DBDs, but have CLF peptides from IDRs.

3) Do not have CLF peptides from IDRs, but have CLF peptides from non-DBD domains (expected, unclear, or not expected).

4) Do not have CLF peptides from non-DBD domains, but have CLF peptides from non-domain or non-ID regions.

```{r, include=T}
other.matches.classified = read.delim("output/space_spacemap-clf_shared_peptides_dbps_nondbds_final.txt")

idr.matched.proteins = unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, ipr.accession, ipr.description) %>%
  distinct() %>%
  filter(ipr.accession == "") %>%
  pull(Uniprot.ID) %>%
  unique() 

idr.matched.proteins.n = length(idr.matched.proteins)

# other.domain.matches = unmatched.proteins.other_matches %>%
#   filter(site.matched) %>%
#   filter(match.peptide.overlap) %>%
#   dplyr::select(Uniprot.ID, ipr.accession, ipr.description) %>%
#   distinct() %>%
#   filter(ipr.accession != "") %>%
#   filter(!Uniprot.ID %in% idr.matched.proteins) %>%
#   pull(Uniprot.ID) %>%
#   unique() 
# 
# other.domain.matched.n = length(other.domain.matches)

other.domain.matched.expected = unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, ipr.accession, ipr.description) %>%
  distinct() %>%
  filter(ipr.accession != "") %>%
  filter(!Uniprot.ID %in% idr.matched.proteins) %>%
  dplyr::left_join(other.matches.classified,
                   by = c("ipr.accession" = "ipr.accession",
                          "ipr.description" = "ipr.description")) %>%
  filter(expected == "Yes") %>%
  pull(Uniprot.ID) %>%
  unique() 

other.domain.matched.expected.n = length(other.domain.matched.expected)

other.domain.matched.unclear = unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, ipr.accession, ipr.description) %>%
  distinct() %>%
  filter(ipr.accession != "") %>%
  filter(!Uniprot.ID %in% c(idr.matched.proteins,
                            other.domain.matched.expected)) %>%
  dplyr::left_join(other.matches.classified,
                   by = c("ipr.accession" = "ipr.accession",
                          "ipr.description" = "ipr.description")) %>%
  filter(expected == "Unclear") %>%
  pull(Uniprot.ID) %>%
  unique() 

other.domain.matched.unclear.n = length(other.domain.matched.unclear)

other.domain.matched.unexpected = unmatched.proteins.other_matches %>%
  filter(site.matched) %>%
  filter(match.peptide.overlap) %>%
  dplyr::select(Uniprot.ID, ipr.accession, ipr.description) %>%
  distinct() %>%
  filter(ipr.accession != "") %>%
  filter(!Uniprot.ID %in% c(idr.matched.proteins,
                            other.domain.matched.expected,
                            other.domain.matched.unclear)) %>%
  dplyr::left_join(other.matches.classified,
                   by = c("ipr.accession" = "ipr.accession",
                          "ipr.description" = "ipr.description")) %>%
  filter(expected == "No") %>%
  pull(Uniprot.ID) %>%
  unique() 

other.domain.matched.unexpected.n = length(other.domain.matched.unexpected)

nonregion.matched.proteins = unmatched.proteins.other_matches %>%
  filter(!site.matched) %>%
  pull(Uniprot.ID) %>%
  unique() 

nonregion.matched.proteins.n = length(nonregion.matched.proteins)

data.frame(category = c("Matched DBD", 
                        "Matched IDR", 
                        "Matched other domain - expected",
                        "Matched other domain - unclear",
                        "Matched other domain - unexpected",
                        "No matched regions"),
           feature = c("DBPs with known DBDs"),
           fraction = c(matched.proteins.n / all.proteins.n,
                        idr.matched.proteins.n / all.proteins.n,
                        other.domain.matched.expected.n / all.proteins.n,
                        other.domain.matched.unclear.n / all.proteins.n,
                        other.domain.matched.unexpected.n / all.proteins.n,
                        nonregion.matched.proteins.n / all.proteins.n)) %>%
  mutate(category = factor(category, levels = rev(c("Matched DBD", 
                                                    "Matched IDR", 
                                                    "Matched other domain - expected", 
                                                    "Matched other domain - unclear", 
                                                    "Matched other domain - unexpected", 
                                                    "No matched regions")))) %>%
  ggplot(aes(x = feature, y = fraction)) +
    geom_col(aes(fill = category)) +
    theme_classic()
```

Hence, ~94% of matches are either a DBD, or an IDR (both of which can be used to bind DNA), or another (but expected) domain (either a putative DBD or a protein-protein-interaction domain). A protein-protein-interaction domain could allow the proteins to bind to DNA indirectrly, by contacting other chromatin proteins.

Check the total number of DBPs and the number of DBPs with known (classical) DBDs:

```{r, include=T}
cat("Total number of DBPs:", 
    clf.ipr.matches.base %>% 
      filter(is.cbp) %>%
      pull(Uniprot.ID) %>%
      unique() %>%
      length(), 
    "\n")

cat("Number of DBPs with classical DBDs:", 
    clf.ipr.matches.base %>% 
      filter(is.cbp) %>%
      filter(ipr.accession %in% dbd.table$ipr_accession) %>%
      pull(Uniprot.ID) %>%
      unique() %>%
      length(), 
    "\n")
```

Hence, only ~32% (109/337) of DBPs have classical DBDs.

Check matches in DBPs that do not have classical DBDs:

```{r, include=T}
proteins.with.dbds = clf.ipr.matches.base.dbd_matches %>% 
  pull(Uniprot.ID) %>% 
  unique()

clf.ipr.matches.base %>% 
  filter(is.cbp) %>%
  filter(!Uniprot.ID %in% proteins.with.dbds) %>%
  dplyr::count(Uniprot.ID, ipr.accession, ipr.description) %>%
  distinct() %>%
  group_by(ipr.accession, ipr.description) %>%
  do(mutate(., protein.n = nrow(.))) %>%
  ungroup() %>%
  dplyr::select(ipr.accession, ipr.description, protein.n) %>%
  distinct() %>%
  arrange(desc(protein.n))
```

